<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>搭建个人博客 github + hexo + NexT</title>
    <url>/2020/09/09/build_your_blog_hexo/</url>
    <content><![CDATA[<h1 id="搭建个人博客-hexo"><a href="#搭建个人博客-hexo" class="headerlink" title="搭建个人博客 hexo"></a>搭建个人博客 hexo</h1><p>这篇文章介绍从0到1搭建个人博客, 基于 Github.io + hexo + NexT，完全免费也美观，对于个人博客来说完全够了，半天内可以搭建并自定义完成个人博客，推荐！<br><a id="more"></a></p>
<ul>
<li>基于github与hexo搭建博客，完全免费</li>
<li>hexo提供许多现成主题模板</li>
<li>经过配置后可使用latex。</li>
</ul>
<h2 id="建立-hexo-博客站点步骤"><a href="#建立-hexo-博客站点步骤" class="headerlink" title="建立 hexo 博客站点步骤"></a>建立 hexo 博客站点步骤</h2><ul>
<li>github 新建一个repository， 名称为 <code>你的GitHub用户名.github.io</code></li>
<li>确保NodeJS的安装目录与Git的安装目录在同一个文件夹下（<a href="https://stackoverflow.com/questions/45513441/npm-command-not-found-in-windows-10">参考</a>）</li>
<li>下载并安装NodeJS</li>
<li>下载并安装Git for Windows</li>
<li>打开Git bash 配置Git的用户名与邮箱为github用户名与邮箱，生成本地ssh并复制到github ssh上 （第一次使用Git设置，如果已经设置过，可以跳过该步骤）</li>
<li>选定一个文件夹作为存放博客文件的目录，以管理员身份打开Git bash， 并 cd 到该目录</li>
<li>导入nodejs路径到<code>git export PATH=$PATH:&quot;/D/path_to_nodejs&quot;</code> (windows path)</li>
<li>输入命令 <code>npm install hexo-cli -g</code></li>
<li>输入命令 <code>hexo init blog</code></li>
<li>输入命令 <code>cd blog</code></li>
<li>输入命令 <code>npm install</code></li>
<li>输入命令 <code>hexo s</code><br>s是server的缩写，表示启动本地服务器。默认情况下，访问网址是：<a href="http://localhost:4000/">http://localhost:4000/</a> 。如果成功的话可以看见官方的默认页面。</li>
<li>在blog文件夹下编辑_config.yml, 找到相应字段，修改如下<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://你的GitHub用户名.github.io/</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/你的GitHub用户名/你的GitHub用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></li>
<li>输入命令<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure></li>
<li>10几20分钟后打开浏览器，输入你的网站地址：<a href="https://你的GitHub用户名.github.io/，就可以看到你的网站已经上线了">https://你的GitHub用户名.github.io/，就可以看到你的网站已经上线了</a></li>
</ul>
<h2 id="新建并发布文章"><a href="#新建并发布文章" class="headerlink" title="新建并发布文章"></a>新建并发布文章</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo n <span class="string">&quot;newblog&quot;</span></span><br><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>
<p>在Git bash 命令行输入 hexo n “newblog”, 就可以看到在blog/source/_posts目录下多了一个newblog.md文件。写完之后生成、部署即可(运行 hexo g -d)。<br>要删除文章的话，直接把源文件删除即可（确保至少有一篇文章存在，否则可能出错）<br>同步到github.io通常要等待一段时间</p>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/78467553">一小时搭建完自己的个人网站</a></p>
<h2 id="常用的配置"><a href="#常用的配置" class="headerlink" title="常用的配置"></a>常用的配置</h2><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>Hexo有许多好看的主题，以NexT主题为例（使用的是NexT 7.8.0版本）：<br>下载主题：Releases · theme-next/hexo-theme-next<br>解压所下载的压缩包至站点的 themes 目录下，并将解压后的文件夹名称（hexo-theme-next-x.x.x）更改为 next<br>打开站点配置文件_config.yml，找到 theme 字段，并将其值更改为 next ；找到 language 字段，并将其值更改为 zh-CN（在themes/next/languages目录下可查看主题支持的语言）<br>在切换主题之后，使用 hexo clean 命令来清除 Hexo 的缓存</p>
<h3 id="LaTeX支持"><a href="#LaTeX支持" class="headerlink" title="LaTeX支持"></a>LaTeX支持</h3><p><a href="https://theme-next.js.org/docs/third-party-services/math-equations.html">配置latex</a></p>
<h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><p>安装一个能上传本地图片的插件：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><br>我一般会atom写markdown，多个blog的图片统一放在assets中</p>
<h3 id="文章添加tags-amp-category"><a href="#文章添加tags-amp-category" class="headerlink" title="文章添加tags&amp;category"></a>文章添加tags&amp;category</h3><p>设置blog\scaffolds\post, 每次 hexo n “new_blog” 默认会出现的标题<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 两数之和</span><br><span class="line">date: 2020-09-09 12:12:57</span><br><span class="line">categories:</span><br><span class="line">- 算法练习</span><br><span class="line">- leetcode</span><br><span class="line">tags:</span><br><span class="line">- 双指针</span><br><span class="line">- 哈希表</span><br><span class="line">---</span><br></pre></td></tr></table></figure><br>注意如上的categories是有层级关系的，leetcode从属于算法练习</p>
<h3 id="更换博客图片背景，设置透明度"><a href="#更换博客图片背景，设置透明度" class="headerlink" title="更换博客图片背景，设置透明度"></a>更换博客图片背景，设置透明度</h3><p>在 根目录/source下新建_data/styles.styl, 设置如下,<br>背景图片放在 根目录/source/images/<br>字体颜色等均可在这里改，覆盖全局参数<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">// Custom styles.</span><br><span class="line">// 整体背景设置</span><br><span class="line">body &#123;</span><br><span class="line">  background:url(/images/1_compress.jpg);// 设定背景图片,images同处于blog/<span class="built_in">source</span>文件夹下</span><br><span class="line"> 	background-repeat: no-repeat;// 设定背景图片非重复填充</span><br><span class="line">    background-attachment:fixed;// 设置背景图片不随页面滚动</span><br><span class="line">    background-position:50% 50%;// 设置背景图片位置</span><br><span class="line">  background-size: cover// 设置保持图像的纵横比并将图像缩放成将完全覆盖背景定位区域的最小大小</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 文章内容的透明度设置</span><br><span class="line">.content-wrap &#123;</span><br><span class="line">  opacity: 0.86;</span><br><span class="line">  color: <span class="comment">#000000;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// sidebar侧边工具栏样式属性</span><br><span class="line">.sidebar&#123;</span><br><span class="line">  opacity: 0.86</span><br><span class="line">  color: <span class="comment">#000000;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 页面头样式属性</span><br><span class="line">.header-inner &#123;</span><br><span class="line">  background: rgba(255,255,255,0.86);</span><br><span class="line">  color: <span class="comment">#000000;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 页脚颜色</span><br><span class="line">.footer &#123;</span><br><span class="line">  color: <span class="comment">#DCDCDC;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 搜索框（local-search）的透明度设置</span><br><span class="line">.popup &#123;</span><br><span class="line">  opacity: 0.86;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 向上箭头</span><br><span class="line">.back-to-top &#123;</span><br><span class="line">    opacity: 1;</span><br><span class="line">    line-height: 2.8;</span><br><span class="line">    right: 35px;</span><br><span class="line">    padding-right: 5px;</span><br><span class="line">    padding-left: 5px;</span><br><span class="line">    padding-top: 2.5px;</span><br><span class="line">    padding-bottom: 2.5px;</span><br><span class="line">    background-color: rgba(28, 28, 28, 1);</span><br><span class="line">    border-radius: 5px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="next主题美化与第三方插件"><a href="#next主题美化与第三方插件" class="headerlink" title="next主题美化与第三方插件"></a>next主题美化与第三方插件</h3><p>参考：</p>
<ul>
<li><a href="https://theme-next.js.org/docs/">NexT文档</a></li>
<li><a href="https://tding.top/archives/42c38b10.html">这个博客里有一系列教程,推荐!注意有些设置是低版本的</a></li>
<li><a href="http://eternalzttz.com/hexo-next.html">hexo NexT 主题美化，注意有些设置是低版本的</a></li>
<li><a href="https://tding.top/archives/58cff12b.html">Hexo-NexT 添加打字特效、鼠标点击特效</a></li>
<li><a href="https://jrbcode.gitee.io/posts/c13e56cd.html">时钟特效</a></li>
<li><a href="https://blog.csdn.net/weizhixiang/article/details/105112467">点击文章后从头开始阅读全文</a></li>
<li><a href="https://blog.csdn.net/chrishly3/article/details/103992492">next主题添加背景图片(无custom.styl情况)</a></li>
</ul>
<h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>一开始我启用了 <a href="https://www.tidio.com/panel/settings/live-chat/appearance">tidio</a> 在线聊天，busuanzi 站点访问统计<br>分析网页加载性能时，瓶颈主要在他们。介于对我来说，他们没那么重要，我就把他们都disable了，网页加载快了很多。</p>
<h3 id="关于TOC中文跳转失效的bug"><a href="#关于TOC中文跳转失效的bug" class="headerlink" title="关于TOC中文跳转失效的bug"></a>关于TOC中文跳转失效的bug</h3><p>NexT 7.3 以后版本自带toc了，在主题的config.yml中enable即可。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">toc:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure><br>但是遇到的问题是，当文章目录 toc 含有中文时，点击左侧目录栏无法正常跳转，查了很多资料，都没能解决（例如卸载hexo-toc（这东西就不用装）,标题文件命名规则等）。结果发现原来是js解析id的问题。。<br>打开node_modules\hexo\lib\plugins\helper\toc.js，修改如下<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// const href = id ? `#$&#123;encodeURL(id)&#125;` : null;</span></span><br><span class="line"><span class="keyword">const</span> href = id ? <span class="string">`#<span class="subst">$&#123;id&#125;</span>`</span> : <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><br>注意如果标题中含有空格，会被解析成-。但这些都不影响使用，把encodeURL去掉，就一切正常了。</p>
<h3 id="禁止部分markdown-gitalk-评论"><a href="#禁止部分markdown-gitalk-评论" class="headerlink" title="禁止部分markdown gitalk 评论"></a>禁止部分markdown gitalk 评论</h3><p>题头添加 comments: false<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: about</span><br><span class="line">date: 2020-09-09 13:26:08</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>hexo博客搭建</category>
      </categories>
      <tags>
        <tag>hexo博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉总结</title>
    <url>/2020/09/14/computer-vision-overview/</url>
    <content><![CDATA[<h1 id="计算机视觉总结"><a href="#计算机视觉总结" class="headerlink" title="计算机视觉总结"></a>计算机视觉总结</h1><p>研究生阶段一直在做计算机视觉方面的研究，想把积累的一些知识梳理总结下，这方面的知识繁多，触类旁通，只能说试着总结记录在这篇blog中。计算机视觉方面的研究很容易给人带来兴趣。从传统数字图像处理到AI深度学习，计算机视觉方面的研究一直是各个领域中的领头羊，其一些成熟的经验也对语音，推荐等方面有较好的借鉴价值。有些人说AI的噱头也很大，但我自己真正比较过，不得不说深度学习真的给计算进一步理解图片带来很大的进步。</p>
<a id="more"></a>
<h2 id="目标检测总结"><a href="#目标检测总结" class="headerlink" title="目标检测总结"></a>目标检测总结</h2><p>自己看过很多目标检测相关的开源代码、框架，自己也写过专用检测网络部署在机器人或者开发板上。目标检测也是一个庞大的知识体系，有兴趣的话可以自己找几篇综述。从 传统的卷积+svm 到现在的深度学习，从 anchor based 到 anchor free，从 two stage 到 one stage。希望大家能够通过这篇文章，快速梳理清不同目标检测框架的核心（主要是深度学习方面的），并能够独立开展自己的研究。<br>目标检测的目的是输出待检测物体bbox的位置(x1,x2,y1,y2)及其分类cls。<br><img data-src="/2020/09/14/computer-vision-overview/20200420_170516_55.png" alt="20200420_170516_55"></p>
<h3 id="不同目标检测网络间的核心区别"><a href="#不同目标检测网络间的核心区别" class="headerlink" title="不同目标检测网络间的核心区别"></a>不同目标检测网络间的核心区别</h3><p>不同的目标检测网络层出不穷，但是最核心的就是以下三点，从这三点出发，可以帮你梳理清楚任何一个目标检测网络以及与其他网络之间的区别</p>
<ul>
<li><strong>如何定义正负样本</strong><br>训练一个目标检测网络，真值是目标框bbox的u,v坐标和类别。如何定义正样本，使得图片经过神经网络后，就能输入相应的检测框呢？</li>
<li><strong>如何优化损失函数</strong><br>损失函数是训练过程的优化目标，如何设计损失函数更好的激活准确的输出呢？</li>
<li><strong>使用的神经网络结构</strong><br>具体使用什么网络结构，什么卷积核，什么激活函数，什么插值方法 …呢？</li>
</ul>
<h3 id="目标检测网络的分类"><a href="#目标检测网络的分类" class="headerlink" title="目标检测网络的分类"></a>目标检测网络的分类</h3><p>通用目标检测网络基于<code>是否使用预定义的anchor</code>可分为：</p>
<ul>
<li>Anchor Based 网络：Faster-RCNN, RetinaNet, SSD,</li>
<li>Anchor Free  网络: CornetNet, CenterNet, FCOS, Yolo …</li>
</ul>
<p>anchor 其实是从传统cv延续来的概念，在深度学习的训练中任然显得很重要，因为可以有效减少回归方差，稳定loss。得益于backbone特征提取的有效性不断提升，2018年开始出现许多 anchor free 的网络，与 anchor based 网络相比，anchor free 网络更简单，正样本的定义更直接，可以避免训练与预测阶段密集 anchor 生成和IoU的计算量。然而 anchor free 的网络在 test set 与 train set 有较明显的 domain gap 的时候表现不如 anchor based 的网络稳定，False positive 的检测偏多。原因是正样本的定义方式，使得正负样本数目上的不平衡性加剧。</p>
<p>目标检测网络基于<code>是否提供 foreground/background region proposals</code> 可分为:</p>
<ul>
<li>Two stage 网络: Faster-RCNN</li>
<li>One stage 网络: Yolo, RetinaNet, Retinaface …</li>
</ul>
<p>因为实时性的要求我主要接触的都是基于one stage的网络，但是two-stage的网络如 Faster-RCNN，虽然速度不够快，anchor计算较繁琐，任然被广泛使用。尤其是一些拓展性工作，比如基于 proposal 的 feature 进一步 embedding，或者像 Mask-RCNN 进一步语义分割。虽然two stage网络中 anchor 的准备工作带来额外开销，但是由于有多任务监督loss，其实Faster-RCNN 的训练速度并不比一些的one-stage网络慢，至今任是一个稳定有效的通用网络。</p>
<p>不能单纯的看各个网络在coco的跑分，针对具体的业务场景，合适的才是好的。</p>
<h3 id="典型目标检测网络之间的异同"><a href="#典型目标检测网络之间的异同" class="headerlink" title="典型目标检测网络之间的异同"></a>典型目标检测网络之间的异同</h3><p>下面我将以Faster-RCNN, RetinaNet, Yolov3, CenterNet这四个很有代表性的网络为例，<br>从<strong>如何定义正负样本</strong>，<strong>如何优化损失函数</strong>，<strong>使用的神经网络结构</strong> 这三个方面分析他们的异同。</p>
<h4 id="yolov1-v2-v3-异同"><a href="#yolov1-v2-v3-异同" class="headerlink" title="yolov1, v2, v3 异同"></a>yolov1, v2, v3 异同</h4><ol>
<li>如何定义正负样本</li>
</ol>
<ul>
<li>v1: 物体中心落在哪个grid, 哪个grid就负责检测该物体.xyhw直接作为归回目标(图片被分为7x7grids)</li>
<li>v2: 物体中心落在哪个grid,和该grid的anchor计算IoU,匹配的anchor与GT的delta作为归回目标</li>
<li>v3: 与GT IoU最大的anchor与GT的delta作为回归目标</li>
</ul>
<ol>
<li>如何优化损失函数</li>
</ol>
<ul>
<li>v1: l2 loss, softmax loss</li>
<li>v2: l2 loss, softmax loss</li>
<li>v3: 只有wh用的 l2 loss, 其他均为sigmoid BCE loss, 引入了bbox scale loss</li>
</ul>
<ol>
<li>网络结构的不同</li>
</ol>
<ul>
<li>v1: 卷积+全连接层(dropout)</li>
<li>v2: darknet19, 全卷积(batchnorm)</li>
<li>v3: darknet53, FPN</li>
</ul>
<h4 id="yolo-与-RetinaNet-的不同"><a href="#yolo-与-RetinaNet-的不同" class="headerlink" title="yolo 与 RetinaNet 的不同"></a>yolo 与 RetinaNet 的不同</h4><ol>
<li>如何定义正负样本</li>
</ol>
<ul>
<li>yolov3，RetinaNet 都是以与GT IoU最大的anchor与GT的delta作为回归目标。小区别：based anchor 数目不同, RetinaNet每个尺度下9个, yolov3 每个尺度下3个。</li>
</ul>
<ol>
<li>如何优化损失函数</li>
</ol>
<ul>
<li>RetinaNet 使用的是Focal loss 与 smooth l1</li>
<li>yolov3 只有wh用的 l2 loss, 其他均为sigmoid BCE loss, 引入了bbox scale loss</li>
</ul>
<ol>
<li>网络结构的不同</li>
</ol>
<ul>
<li>yolov3 的FPN不是标准的FPN,8/16/32的特征图还经过几层conv才concat融合, FPN是add特征图相加</li>
<li>RetinaNet cls,bbox各一个分支. yolo cls,bbox在一个分支里.</li>
<li>RetinaNet FPN不同尺度之间,head参数共享, yolov3 独立</li>
</ul>
<h4 id="RetinaNet-与-Retinaface-的不同"><a href="#RetinaNet-与-Retinaface-的不同" class="headerlink" title="RetinaNet 与 Retinaface 的不同"></a>RetinaNet 与 Retinaface 的不同</h4><ol>
<li>如何定义正负样本</li>
</ol>
<ul>
<li>Retanaface 每个尺度两个不同大小的正方形based anchor</li>
</ul>
<ol>
<li>如何优化损失函数</li>
</ol>
<ul>
<li>cls loss采用sampling的办法, 取topk个CE loss</li>
</ul>
<ol>
<li>网络结构的不同</li>
</ol>
<ul>
<li>Retanaface 论文中不同尺度间head参数共享,但实际代码独立</li>
<li>Retanaface 引入 SSH layer, 融合3x3, 5x5, 7x7的特征,实际实现中用的两次,三次卷积代替5x5,7x7卷积</li>
</ul>
<h4 id="RetinaNet-与-Faster-RCNN-的不同"><a href="#RetinaNet-与-Faster-RCNN-的不同" class="headerlink" title="RetinaNet 与 Faster RCNN 的不同"></a>RetinaNet 与 Faster RCNN 的不同</h4><ol>
<li>如何定义正负样本</li>
</ol>
<ul>
<li>Faster RCNN 属于 two stage，每个stage各有GT，stage one 只区分前景与背景，stage two 再具体区分类别或者还是背景。stage two 中的 正负anchor样本 以 1：3 比例从stage one 中的 anchor 采样。</li>
</ul>
<ol>
<li>如何优化损失函数</li>
</ol>
<ul>
<li>cls loss采用sampling的办法, 取topk个CE loss</li>
</ul>
<ol>
<li>网络结构的不同</li>
</ol>
<ul>
<li>Retanaface 论文中不同尺度间head参数共享,但实际代码独立</li>
<li>Retanaface 引入 SSH layer, 融合3x3, 5x5, 7x7的特征,实际实现中用的两次,三次卷积代替5x5,7x7卷积</li>
</ul>
<h3 id="Faster-RCNN"><a href="#Faster-RCNN" class="headerlink" title="Faster-RCNN"></a>Faster-RCNN</h3><hr>
<h3 id="RetinaNet"><a href="#RetinaNet" class="headerlink" title="RetinaNet"></a>RetinaNet</h3><p>这里以 RetinaNet 展开，具体介绍下吧<br>RetinaNet是出了名的许多重复的层可以坎，一个典型的例子就是Retinaface. 可以去学习下RetinaNet<br>对于简单专业的检测任务，如何针对性的简化网络</p>
<h4 id="真值定义"><a href="#真值定义" class="headerlink" title="真值定义"></a>真值定义</h4><p>在下采样的FPN特征图上，每个网格配备9个based-anchor. 这9个based-anchor有三个不同的尺寸，<br>长宽比分别为 1:2, 1:1, 2:1. 对于batch里每个图片，都会基于其特征图，每个网格生成based-anchor。<br>与GT物体bbox的IoU大于阈值0.5的based-anchor被定义为正样本，介于0.4,0.5之间的被定义为ignored，<br>小于0.4的定义为负样本。阈值可以自己调整。based-anchor的尺寸可以自己设定，尤其要小心的是，<br>不同数据集，源图片尺寸与coco数据集不一样，图片预处理后如果大小与网络本身预设输入的的尺寸不一致，<br>需要基于新的尺寸重新修改based-anchor size，如果一样，则不需要修改based-anchor size 尺寸。<br>因为based-anchor size已经基于原图片尺寸，卷积层感受野进行过合理配置，便于后续提供良好的<br>anchor matching(based-anchor与bbox GT)得到尽可能多的正样本。此时花时间调整based-anchor size<br>参数花时间并且通常效果更差。</p>
<p>对于类别回归的真值定义：<br>物体GT bbox的类别会被one-hot编码，与其IoU大于阈值的based-anchor被定义为正样本，也就是网络<br>最后一层的输出。其后不接batchnorm 和 activation。计算loss前, sigmoid缩放到(0,1)<br>$ sigmoid = \frac{1}{1 + e^{-x}} $<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.Conv2d(in_channels, num_anchors*num_classes, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><br>正样本(one-hot编码的物体类别)与负样本(background)作为类别回归的真值。<br>网络class head 最终输出的out channel维度为 (num_anchors<em>num_classes)。<br>num_anchors为9，是特征图每个网格配备的based-anchor数目。<br>ps: 注意与Faster-RCNN 不同，Faster-RCNN class head 输出维度为 ((class_num+1) </em> 9)，<br>1 是 background，最后一层输出后接softmax。</p>
<p>对于bbox位置回归的真值定义：<br>每个based-anchor去回归delta cx, delta cy, delta h, delta w。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.Conv2d(in_channels, num_anchors*<span class="number">4</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><br>小的variance对网络的训练更好，因此网络并不是直接回归物体bbox的 cx,cy,h,w。<br>而是去回归物体bbox中心cx,cy基于其匹配的based_anchor中心的差值，并除以based_anchor的尺度<br>h,w 也同理。物体尺度相对于based_anchor的尺度的log。这些处理很巧妙的配合了图片归一化的前处理，<br>与batch normalization,使得网络能够更快更稳定收敛。<br>bbox gt真值的定义如下，直接看伪代码其实更方便理解。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dx = (gt_cx - based_anchor_cx) / based_anchor_widths</span><br><span class="line">dy = (gt_cy - based_anchor_cy) / based_anchor_heights</span><br><span class="line">dw = ln(gt_widths / based_anchor_widths)</span><br><span class="line">dh = ln(gt_heights / based_anchor_heights)</span><br><span class="line">deltas = torch.stack((dx, dy, dw, dh), dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="loss计算"><a href="#loss计算" class="headerlink" title="loss计算"></a>loss计算</h4><h5 id="binary-loss"><a href="#binary-loss" class="headerlink" title="binary loss"></a>binary loss</h5><script type="math/tex; mode=display">sigmoid = \frac{1}{1 + e^{-x}}</script><script type="math/tex; mode=display">L = L_{neg} + L_{pos} = -\sum\limits_{i=1}^n log(1-p) - \sum\limits_{i=1}^n log(p)</script><script type="math/tex; mode=display">L = -ylog(p)-(1-y)log(1-p)</script><h5 id="CE-loss"><a href="#CE-loss" class="headerlink" title="CE loss"></a>CE loss</h5><script type="math/tex; mode=display">L = -\sum\limits_{i=1}^n log(p)</script><h5 id="softmax-loss"><a href="#softmax-loss" class="headerlink" title="softmax loss"></a>softmax loss</h5><script type="math/tex; mode=display">softmax = \frac {e^{p_i}}{\sum\limits_{j=1}^n e^{p_j}}</script><script type="math/tex; mode=display">-\sum\limits_{i=1}^n log(\frac {e^{z_i}}{\sum\limits_{j=1}^n e^{z_j}})</script><h5 id="分类loss"><a href="#分类loss" class="headerlink" title="分类loss"></a>分类loss</h5><p>只有正样本与负样本会参与分类loss计算,被ignored的based-anchor不参与计算。分类loss是基于交叉熵的，优化的是概率。对于正样本，loss监督网络在其对应的class_id层有接近1的输出。对于负样本，loss监督网络在其对应输出层输出接近0。focal loss 是常见的one stage detector的分类loss，基于CE交叉熵loss，提出 1.优化正样本与background不平衡问题（可能只有几百个based_anchor与GT bbox匹配成功，其余十几万的都是负样本，负样本有可能主导分类loss） 2.重点优化难训练样本的概率见下图。focal loss中 1. alpha_t正样本权重，1-alpha_t负样本权重，解决正样本与background的不平衡 2. gamma，在ce_loss前乘上 $(1 - p_t)^{\gamma}$，减少预测正确的大概率样本的loss，见下图。当gamma = 0, focal loss = CE loss</p>
<script type="math/tex; mode=display">FL(p_t) = -\alpha_t (1-p_t)^\gamma log(p_t)</script><p><img data-src="/2020/09/14/computer-vision-overview/20200424_232127_48.png" alt="20200424_232127_48"></p>
<p>直接看下伪代码吧。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://arxiv.org/pdf/1708.02002.pdf focal loss paper</span></span><br><span class="line">p = torch.sigmoid(predicts)</span><br><span class="line">ce_loss = torch.nn.functional.binary_cross_entropy_with_logits(predicts, targets, reduction=<span class="string">&quot;none&quot;</span>)</span><br><span class="line">p_t = p * targets + (<span class="number">1</span> - p) * (<span class="number">1</span> - targets)</span><br><span class="line">loss = ce_loss * ((<span class="number">1</span> - p_t) ** gamma)</span><br><span class="line"><span class="keyword">if</span> alpha &gt;= <span class="number">0</span>:</span><br><span class="line">    alpha_t = alpha * targets + (<span class="number">1</span> - alpha) * (<span class="number">1</span> - targets)</span><br><span class="line">    loss = alpha_t * loss</span><br><span class="line">loss = loss.sum()</span><br><span class="line">loss = loss / max(<span class="number">1</span>, num_matched_based_anchors)</span><br><span class="line"><span class="keyword">return</span> loss</span><br></pre></td></tr></table></figure>
<p>由于正负样本数目间悬殊的差距，会造成训练初期不稳定，focal loss 还提出网络权重初始化的问题，让模型训练初期正样本的预测更少，负样本的更多，获得一个更稳定更小的初期的训练loss，这个我在第一次看的时候完全没有注意到。网络class head最后一层的bias被设置成 $ -log((1-\pi)/\pi) $, 其中$\pi=0.01$。 其他层（backbone除外），被设置为<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.init.normal_(layer.weight, mean=<span class="number">0</span>, std=<span class="number">0.01</span>)</span><br><span class="line">torch.nn.init.constant_(layer.bias, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="yolov3-loss"><a href="#yolov3-loss" class="headerlink" title="yolov3 loss"></a>yolov3 loss</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xy_loss = object_mask * box_loss_scale * K.binary_crossentropy(raw_true_xy, raw_pred[...,<span class="number">0</span>:<span class="number">2</span>], from_logits=<span class="literal">True</span>)</span><br><span class="line">wh_loss = object_mask * box_loss_scale * <span class="number">0.5</span> * K.square(raw_true_wh-raw_pred[...,<span class="number">2</span>:<span class="number">4</span>])</span><br><span class="line">confidence_loss = object_mask * K.binary_crossentropy(object_mask, raw_pred[...,<span class="number">4</span>:<span class="number">5</span>], from_logits=<span class="literal">True</span>)+ \</span><br><span class="line">    (<span class="number">1</span>-object_mask) * K.binary_crossentropy(object_mask, raw_pred[...,<span class="number">4</span>:<span class="number">5</span>], from_logits=<span class="literal">True</span>) * ignore_mask</span><br><span class="line">class_loss = object_mask * K.binary_crossentropy(true_class_probs, raw_pred[...,<span class="number">5</span>:], from_logits=<span class="literal">True</span>)</span><br><span class="line">loss = xy_loss + wh_loss + confidence_loss + class_loss</span><br></pre></td></tr></table></figure>
<h4 id="IoU"><a href="#IoU" class="headerlink" title="IoU"></a>IoU</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iou_calculate</span>(<span class="params">bbox1, bbox2</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">      bbox1: bounding boxes, size [N, 4] (xmin, ymin, xmax, ymax)</span></span><br><span class="line"><span class="string">      bbox2: bounding boxes, size [M, 4]</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">      IoU, size [N,M]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(bbox1, list): bbox1 = np.array(bbox1)</span><br><span class="line">    <span class="keyword">if</span> isinstance(bbox2, list): bbox2 = np.array(bbox2)</span><br><span class="line"></span><br><span class="line">    bbox1_area = (bbox1[..., <span class="number">2</span>] - bbox1[..., <span class="number">0</span>]) * (bbox1[..., <span class="number">3</span>] - bbox1[..., <span class="number">1</span>]) <span class="comment"># (N,)</span></span><br><span class="line">    bbox2_area = (bbox2[..., <span class="number">2</span>] - bbox2[..., <span class="number">0</span>]) * (bbox2[..., <span class="number">3</span>] - bbox2[..., <span class="number">1</span>]) <span class="comment"># (M,)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># left_top, right_bottom coordinates iof intersection point</span></span><br><span class="line">    lt_coordinate = np.maximum(bbox1[:, np.newaxis, :<span class="number">2</span>], bbox2[:, :<span class="number">2</span>]) <span class="comment"># (N, M, 2)</span></span><br><span class="line">    rb_coordinate = np.minimum(bbox1[:, np.newaxis, <span class="number">2</span>:], bbox2[:, <span class="number">2</span>:]) <span class="comment"># (N, M, 2)</span></span><br><span class="line"></span><br><span class="line">    intersection = np.maximum(rb_coordinate-lt_coordinate, <span class="number">0</span>) <span class="comment"># (N, M, 2)</span></span><br><span class="line">    inter_area = intersection[..., <span class="number">0</span>] * intersection[..., <span class="number">1</span>]  <span class="comment"># (N, M)</span></span><br><span class="line">    <span class="comment"># always boardcast bbox1[:, np.newaxis] to have dim M</span></span><br><span class="line">    union_area = bbox1_area[:, np.newaxis] + bbox2_area - inter_area <span class="comment"># (N, M)</span></span><br><span class="line">    IoU = inter_area / union_area</span><br><span class="line">    <span class="keyword">return</span> IoU</span><br></pre></td></tr></table></figure>
<h4 id="NMS"><a href="#NMS" class="headerlink" title="NMS"></a>NMS</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nms</span>(<span class="params">bboxes, iou_thresh</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">      bboxes: after score. np.array. (N, 6) [xmin, ymin, xmax, ymax, score, class]</span></span><br><span class="line"><span class="string">      iou_thresh: float</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">      bboxes_nms: np.array. (N&#x27;, 6) [xmin, ymin, xmax, ymax, score, class]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    classes = bboxes[:, <span class="number">5</span>] <span class="comment"># (N,)</span></span><br><span class="line">    unique_classes = set(classes)</span><br><span class="line">    bboxes_nms = []</span><br><span class="line">    <span class="keyword">for</span> cls <span class="keyword">in</span> unique_classes:</span><br><span class="line">        mask = classes == cls <span class="comment"># (N,)</span></span><br><span class="line">        cls_bboxes = bboxes[mask] <span class="comment"># (M, 6)</span></span><br><span class="line">        <span class="comment"># nms in each class</span></span><br><span class="line">        x1, y1 = cls_bboxes[:, <span class="number">0</span>], cls_bboxes[:, <span class="number">1</span>] <span class="comment"># (M,)</span></span><br><span class="line">        x2, y2 = cls_bboxes[:, <span class="number">2</span>], cls_bboxes[:, <span class="number">3</span>]</span><br><span class="line">        scores = cls_bboxes[:, <span class="number">4</span>] <span class="comment"># (M,)</span></span><br><span class="line">        areas = (x2 - x1) * (y2 - y1) <span class="comment"># (M,)</span></span><br><span class="line">        order = scores.argsort()[::<span class="number">-1</span>] <span class="comment"># (M,)</span></span><br><span class="line">        keep = []</span><br><span class="line">        <span class="keyword">while</span> order.size &gt; <span class="number">0</span>:</span><br><span class="line">            i = order[<span class="number">0</span>]</span><br><span class="line">            keep.append(i)</span><br><span class="line">            x1_max = np.maximum(x1[i], x1[order[<span class="number">1</span>:]]) <span class="comment"># (1,), (M-1,) -&gt; (M-1,)</span></span><br><span class="line">            y1_max = np.maximum(y1[i], y1[order[<span class="number">1</span>:]])</span><br><span class="line">            x2_min = np.minimum(x2[i], x2[order[<span class="number">1</span>:]])</span><br><span class="line">            y2_min = np.minimum(y2[i], y2[order[<span class="number">1</span>:]])</span><br><span class="line">            w = np.maximum(<span class="number">0</span>, x2_min - x1_max) <span class="comment"># (M-1,)</span></span><br><span class="line">            h = np.maximum(<span class="number">0</span>, y2_min - y1_max)</span><br><span class="line">            inter_area = w * h <span class="comment"># (M-1,)</span></span><br><span class="line">            union_area = areas[i] + areas[order[<span class="number">1</span>:]] - inter_area <span class="comment"># (1,), (M-1,) -&gt; (M-1,)</span></span><br><span class="line">            iou = inter_area / union_area <span class="comment"># (M-1,)</span></span><br><span class="line">            keep_index = np.where(iou &lt;= iou_thresh)[<span class="number">0</span>]</span><br><span class="line">            order = order[keep_index + <span class="number">1</span>]</span><br><span class="line">        keep_bboxes = cls_bboxes[keep]</span><br><span class="line">        bboxes_nms.append(keep_bboxes)</span><br><span class="line">    bboxes_nms = np.vstack(bboxes_nms)</span><br><span class="line">    <span class="keyword">return</span> bboxes_nms</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>computer vision</category>
      </categories>
      <tags>
        <tag>overview</tag>
      </tags>
  </entry>
  <entry>
    <title>决策树 GBDT XGBOOST RF</title>
    <url>/2020/09/15/decision-tree/</url>
    <content><![CDATA[<h1 id="决策树-GBDT-XGBOOST-RF"><a href="#决策树-GBDT-XGBOOST-RF" class="headerlink" title="决策树 GBDT XGBOOST RF"></a>决策树 GBDT XGBOOST RF</h1><p>决策树系列的模型，一直是机器学习里非常重要，并用很广泛的模型。在这篇文章中，总结下决策树系列的模型的异同吧。</p>
<a id="more"></a>
<h2 id="决策树-ID3-C4-5-CART"><a href="#决策树-ID3-C4-5-CART" class="headerlink" title="决策树 ID3 C4.5 CART"></a>决策树 ID3 C4.5 CART</h2><p>决策树 是由多个基树（子树） 组成的，其中最重要的子树是 ID3, C4.5, CART 树，分别使用的是 信息增益，信息增益比 和 基尼系数 作为节点分裂的标准。ID3, C4.5是多叉树，CART树是二叉树。</p>
<p>信息熵, 代表系统的不确定性<br>$c_i$ 代表其中一个类别</p>
<script type="math/tex; mode=display">H(c) = -\sum_{i=1}^n p(c_i) log(p(c_i))</script><p>条件熵, 当特征X的分布被固定时系统的信息熵 H(c|X)</p>
<script type="math/tex; mode=display">H(c|X) = -\sum_{i=1}^n p(x_i)H(c|x=x_i)</script><script type="math/tex; mode=display">= -\sum_{i=1}^n  p(x_i)p(c|x=x_i) log(p(c|x=x_i))</script><script type="math/tex; mode=display">= -\sum_{i=1}^n p(c,x_i) log(p(c|x=x_i))</script><p>特征X的信息增益 (ID3使用)：特征X分布被固定时,系统不确定度的减小.<br>信息增益的大小是相对于训练数据集而言的,没有绝对意义,在数据集信息熵大的时候,信息熵也偏大.</p>
<script type="math/tex; mode=display">IG(c,X) = H(c) - H(c|X)</script><script type="math/tex; mode=display">= - \sum_{i=1}^n p(c_i) log(p(c_i)) + \sum_{i=1}^n p(c,x_i) log(p(c|x=x_i))</script><p>特征X的信息增益比 (C4.5使用)</p>
<script type="math/tex; mode=display">g = \frac{IG(c,X)}{H(X)} = \frac{H(c) - H(c|X)}{H(X)}</script><p>CART 基尼系数<br>可以做为熵模型的一个近似替代，避免耗时的对数运算</p>
<script type="math/tex; mode=display">Gini(p) = \sum_{i=1}^n p_i(1 - p_i)</script><p>互信息 两个随机变量之间的相关程度</p>
<p><img data-src="/2020/09/15/decision-tree/20200713_220324_16.png" alt="互信息"></p>
<p>KL散度 衡量两个分布的相似度</p>
<p><img data-src="/2020/09/15/decision-tree/markdown-img-paste-20200819230120460.png" alt="KL散度"></p>
<p>参考</p>
<ul>
<li><a href="https://www.cnblogs.com/pinard/p/6050306.html">https://www.cnblogs.com/pinard/p/6050306.html</a></li>
<li><a href="https://www.cnblogs.com/pinard/p/6053344.html">https://www.cnblogs.com/pinard/p/6053344.html</a></li>
</ul>
<h3 id="CART"><a href="#CART" class="headerlink" title="CART"></a>CART</h3><p>CART分类树算法使用基尼系数来代替信息增益比，基尼系数代表了模型的不纯度，基尼系数越小，则不纯度越低，特征越好。这和信息增益是相反的。</p>
<script type="math/tex; mode=display">Gini(p) = \sum_{k=1}^K p_k(1 - p_k)</script><h4 id="CART分类树对连续特征的处理"><a href="#CART分类树对连续特征的处理" class="headerlink" title="CART分类树对连续特征的处理"></a>CART分类树对连续特征的处理</h4><p>比如m个样本的连续特征A有m个，从小到大排列为𝑎1,𝑎2,…,𝑎𝑚,则CART算法取相邻两样本值的平均数，一共取得m-1个划分点。对于这m-1个点，分别计算以该点作为二元分类点时的基尼系数。选择基尼系数最小的点作为该连续特征的二元离散分类点。</p>
<h4 id="建立CART分类树"><a href="#建立CART分类树" class="headerlink" title="建立CART分类树"></a>建立CART分类树</h4><p>算法输入是训练集D，基尼系数的阈值，样本个数阈值。输出是决策树T。<br>我们的算法从根节点开始，用训练集递归的建立CART分类树。<br>1) 对于当前节点的数据集为D，如果样本个数小于阈值，return。<br>2) 计算样本集D的基尼系数，如果基尼系数小于阈值，return。<br>3) 计算当前节点的各个特征对数据集D的基尼系数.<br>4) 在各特征对数据集D的基尼系数中，选择基尼系数最小的特征A作为最优特征，把数据集划分成两部分D1和D2至左右节点。<br>5) 对左右的子节点递归的调用1-4步，生成决策树。</p>
<p>对于生成的决策树做预测的时候，假如测试集里的样本A落到了某个叶子节点，而节点里有多个训练样本。则对于A的类别预测采用的是这个叶子节点里概率最大的类别。</p>
<h4 id="建立CART回归树"><a href="#建立CART回归树" class="headerlink" title="建立CART回归树"></a>建立CART回归树</h4><p>CART回归树和CART分类树的建立和预测的区别主要有下面两点：<br>1) 连续值的处理方法不同<br>CART分类度量目标是树采用基尼系数最小,CART回归树的度量目标是均方差之和最小。<br>2) 决策树建立后做预测的方式不同。<br>CART分类树采用叶子节点里概率最大的类别作为当前节点的预测类别。而回归树输出不是类别，它采用的是用最终叶子的均值或者中位数来预测输出结果。</p>
<h4 id="CART树建树时间复杂度"><a href="#CART树建树时间复杂度" class="headerlink" title="CART树建树时间复杂度"></a>CART树建树时间复杂度</h4><p>O(NMD), N是sample的大小，M是feature的数量，D是树的深度。cart生长时，把所有feature内的值都作为分裂候选，并为其计算一个评价指标（信息增益、增益比率、gini系数等），所以每层是O(NM)，D层的树就是O(NMD)</p>
<h4 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h4><p>决策树很容易出现的一种情况是过拟合(overfitting)，所以需要进行剪枝。而基本的策略包括两种：预剪枝(Pre-Pruning)与后剪枝(Post-Pruning)。</p>
<p>预剪枝：其中的核心思想就是，在每一次实际对结点进行进一步划分之前，先采用验证集的数据来验证如果划分是否能提高划分的准确性。如果不能，就把结点标记为叶结点并退出进一步划分；如果可以就继续递归生成节点。<br>后剪枝：后剪枝则是先从训练集生成一颗完整的决策树，然后自底向上地对非叶结点进行考察，若将该结点对应的子树替换为叶结点能带来泛化性能提升，则将该子树替换为叶结点。<br>参考 <a href="https://blog.csdn.net/bitcarmanlee/java/article/details/106824993">https://blog.csdn.net/bitcarmanlee/java/article/details/106824993</a></p>
<h3 id="GBDT"><a href="#GBDT" class="headerlink" title="GBDT"></a>GBDT</h3><p>不管是回归还是分类问题，GBDT使用的都是CART回归树, 不断基于负梯度拟合。损失函数除了loss还有正则项，正则中有参数和变量，很多情况下只拟合残差loss变小但是正则变大，代价函数不一定就小，这时候就要用梯度。 用残差去拟合，只是目标函数是MSE均方误差的一种特殊情况。 分类拟合的是概率的负梯度。<br>梯度提升树在函数空间做优化</p>
<p>梯度下降: 每次迭代基于负梯度方向更新权重参数<br>梯度提升: 每次迭代基于负梯度方向更新拟合函数(添加一个新函数)<br>对于新添加的函数取泰勒1阶/2阶近似,通过产生的一阶二阶梯度去拟合这个近似的函数.<br>最终权重参数/函数等于每次迭代增量的累加和.</p>
<h3 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h3><p><a href="https://arxiv.org/pdf/1603.02754.pdf">XGBoost论文</a><br>这个文章xgboost总结的挺好: <a href="https://snaildove.github.io/2018/10/02/get-started-XGBoost/">XGBoost总结</a></p>
<h4 id="GBDT-XGBoost区别"><a href="#GBDT-XGBoost区别" class="headerlink" title="GBDT, XGBoost区别"></a>GBDT, XGBoost区别</h4><p>对比原算法GBDT，XGBoost主要从下面三个方面做了优化：</p>
<ol>
<li>在算法的弱学习器模型选择上，GBDT只支持CART回归数，XGBoost还支持很多其他的弱学习器。GBDT的损失函数只对误差部分做负梯度一阶泰勒展开，而XGBoost损失函数对误差部分做二阶泰勒展开，更加准确。</li>
<li>XGBoost决策树子树分裂特征选择的过程可并行，在连续的缓存中计算负梯度，解压缩时间换IO时间。</li>
<li>加入了L1和L2正则化项，列抽样,子采样,泛化能力更强。</li>
<li>对于缺失值的特征，通过枚举所有缺失值在当前节点是进入左子树还是右子树来决定缺失值的处理方式。</li>
</ol>
<h4 id="XGBoost-并行"><a href="#XGBoost-并行" class="headerlink" title="XGBoost 并行"></a>XGBoost 并行</h4><ol>
<li>XGBoost在处理特征时可以做到并行处理，XGBoost并行原理体现在最优切分点的选择，假设样本数据共M个特征,分别对M个特征分别先预排序,然后以compressed column的形式存储在M个block中(减小内存占用), Block预先放入内存.在寻找每个特征的最优划分点的时候,可以利用多线程对每个block并行计算.</li>
<li>缓存感知:<br>CSC 存储格式会使得数据不在连续的内存里，用普通的访问方式会使得划分查找算法效率降低，并可能导致 cache miss。<br>对于精确贪婪算法，使用缓存感知cache-aware解决问题。首先为每个线程分配一个内部buffer，读取梯度信息并存入buufer中(实现非连续到连续的转化), 然后再在buffer中统计梯度信息。<br>对于近似算法，选取正确的 block 大小就可以解决问题。</li>
<li>核外块的计算<br>为了解决硬盘读取数据耗时长,吞吐量不足.<br>多线程对数据分块压缩(block compression)存储在硬盘上,再将数据传输到内存,最后再用独立的线程解压缩. (用解压缩时间换取IO时间)</li>
</ol>
<p>参考:<a href="https://blog.rocuku.cc/xgboost-summary/">https://blog.rocuku.cc/xgboost-summary/</a><br><a href="https://snaildove.github.io/2018/10/02/get-started-XGBoost/">https://snaildove.github.io/2018/10/02/get-started-XGBoost/</a></p>
<h4 id="XGBoost-损失函数"><a href="#XGBoost-损失函数" class="headerlink" title="XGBoost 损失函数"></a>XGBoost 损失函数</h4><p><img data-src="/2020/09/15/decision-tree/20200714_172640_17.png" alt="20200714_172640_17"><br>L 为损失函数, Omiga为树的复杂度, T 为叶子结点个数，w 为叶子权重。<br><img data-src="/2020/09/15/decision-tree/20200714_174803_81.png" alt="20200714_174803_81"><br>节点分裂公式<br><img data-src="/2020/09/15/decision-tree/20200715_172149_44.png" alt="20200715_172149_44"><br>损失函数本身满足样本之间的累加特性(最大似然取log的好处)，所以，可以通过将分裂前的叶结点上样本的损失函数和与分裂之后的两个新叶结点上的样本的损失函数之和进行对比结合复杂度的控制,计算增益gain，寻找最优特征与最优分割点。</p>
<h4 id="XGBoost防止过拟合的方法"><a href="#XGBoost防止过拟合的方法" class="headerlink" title="XGBoost防止过拟合的方法"></a>XGBoost防止过拟合的方法</h4><ul>
<li>目标函数添加正则项：叶子节点个数+叶子节点权重的L1,L2正则化</li>
<li>列抽样：训练的时候只用一部分特征（不考虑剩余的block块即可）</li>
<li>子采样：每轮计算可以不使用全部样本，使算法更加保守</li>
<li>ealry stop</li>
<li>剪枝</li>
</ul>
<p>这个文章讲的比较好: <a href="https://www.xuyindavid.top/2019/11/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/xgboost/%E7%99%BE%E9%97%AExgboost/">百问XGBoost</a></p>
<h4 id="xgboost-特征重要性筛选"><a href="#xgboost-特征重要性筛选" class="headerlink" title="xgboost 特征重要性筛选"></a>xgboost 特征重要性筛选</h4><p>xgboost实现中Booster类get_score方法输出特征重要性，其中importance_type参数支持三种特征重要性的计算方法：</p>
<ol>
<li>importance_type=weight（默认值），特征重要性使用特征在所有树中作为划分属性的次数。</li>
<li>importance_type=gain，特征重要性使用特征在作为划分属性时loss平均的降低量。</li>
<li>importance_type=cover，特征重要性使用特征在作为划分属性时对样本的覆盖度。</li>
</ol>
<h4 id="不需要归一化原因"><a href="#不需要归一化原因" class="headerlink" title="不需要归一化原因"></a>不需要归一化原因</h4><p>增益gain的计算与特征值范围无关,是采用生成树的结构与权重计算的,所以不需要对特征进行归一化处理.</p>
<h4 id="XGBoost如何处理缺失值"><a href="#XGBoost如何处理缺失值" class="headerlink" title="XGBoost如何处理缺失值"></a>XGBoost如何处理缺失值</h4><p>XGBoost模型的一个优点就是允许特征存在缺失值。对缺失值的处理方式如下：</p>
<ul>
<li>在特征k非缺失的样本上上寻找最佳切分点。</li>
<li>将该特征值缺失的样本分别分配到左叶子结点和右叶子结点，两种情形都计算一遍后，选择分裂后增益最大的那个分支，作为预测时特征值缺失样本的默认分支方向。</li>
<li>如果在训练中没有缺失值而在预测中出现缺失，那么会自动将缺失值的划分方向放到右子结点。</li>
</ul>
<h4 id="XGBoost中的一棵树的停止生长条件"><a href="#XGBoost中的一棵树的停止生长条件" class="headerlink" title="XGBoost中的一棵树的停止生长条件"></a>XGBoost中的一棵树的停止生长条件</h4><ul>
<li>当新引入的一次分裂所带来的增益Gain&lt;0时，放弃当前的分裂。这是训练损失和模型结构复杂度的博弈过程。</li>
<li>当树达到最大深度时，停止建树，因为树的深度太深容易出现过拟合，这里需要设置一个超参数max_depth。</li>
<li>如果一个叶子节点包含的样本数量太少也会放弃分裂，防止树分的太细。</li>
<li>验证集上预剪枝</li>
</ul>
<h4 id="最优切分点划分算法"><a href="#最优切分点划分算法" class="headerlink" title="最优切分点划分算法"></a>最优切分点划分算法</h4><ul>
<li>对每个叶节点枚举所有的可用特征</li>
<li>针对每个特征，把属于该节点的训练样本根据该特征值进行升序排列，从左到右线性扫描决定该特征的最佳分裂点，并记录该特征的分裂增益(左孩子损失+右孩子损失-分裂前损失+复杂度)</li>
<li>选择增益最大的特征作为分裂特征，用该特征的最佳分裂点作为分裂位置，在该节点上分裂出左右两个新的叶节点，并为每个新节点关联对应的样本集<br>每次排序的时间复杂度 O(m nlogn), m为特征类别数, n为样本数. 可以通过预排序节省.</li>
</ul>
<p>近似算法: 上述算法可以得到最优解，但计算量大. 对于每个特征，只考察分位点可以减少计算复杂度.<br>根据分位数采样得到分割点的候选集合S, 将特征k的值根据集合Sk划分到桶(bucket)中，接着对每个桶内样本的增益(梯度G,H)进行累加统计，最后在这些累计的统计量上寻找最佳分裂点。<br>除此之外还有带权重(基于梯度)的分位方案.</p>
<p>参考: <a href="https://zhuanlan.zhihu.com/p/105612830">https://zhuanlan.zhihu.com/p/105612830</a><br><a href="https://yxzf.github.io/2017/04/xgboost-v2/">https://yxzf.github.io/2017/04/xgboost-v2/</a></p>
<h3 id="随机森林-RF"><a href="#随机森林-RF" class="headerlink" title="随机森林 RF"></a>随机森林 RF</h3><p>使用bagging的方法，每次对数据集有放回的随机采样，使用一部分数据训练不同的基学习器，最后再集成起来.<br>随机森林使用CART作为基学习器,不同的是,RF随机选择节点上的一部分特征𝑛𝑠𝑢𝑏，然后在这些随机选择的𝑛𝑠𝑢𝑏个样本特征中，选择一个最优的特征来做决策树的左右子树划分。(nsub越小,模型方差越小,偏差越大.一般通过交叉验证调参获取合适的𝑛𝑠𝑢𝑏) 也可以随机混合使用ID3 C4.5 CART.<br>如果是分类，则T个弱学习器投出最多票数的类别为最终类别。如果是回归，T个弱学习器得到的回归结果进行算术平均得到的值为最终的模型输出。<br>优点:</p>
<ol>
<li>训练与预测过程可以高度并行化</li>
<li>采用随机采样，随机选取节点特征,训练出的模型的方差小，泛化能力强。</li>
</ol>
<h4 id="RF和GBDT的区别"><a href="#RF和GBDT的区别" class="headerlink" title="RF和GBDT的区别"></a>RF和GBDT的区别</h4><p>相同点：</p>
<ul>
<li>都是由多棵树组成，最终的结果都是由多棵树一起决定。</li>
</ul>
<p>不同点：</p>
<ul>
<li>集成学习：RF属于bagging思想，而GBDT是boosting思想</li>
<li>偏差-方差权衡：RF不断的降低模型的方差，而GBDT不断的降低模型的偏差</li>
<li>训练样本：RF每次迭代的样本是从全部训练集中有放回抽样形成的，而GBDT每次使用全部样本</li>
<li>并行性：RF的树可以并行生成，而GBDT只能顺序生成(需要等上一棵树完全生成)</li>
<li>最终结果：RF最终是多棵树进行多数表决（回归问题是取平均），而GBDT是加权融合</li>
<li>数据敏感性：RF对异常值不敏感，而GBDT对异常值比较敏感</li>
<li>泛化能力：RF不易过拟合，而GBDT容易过拟合</li>
</ul>
<h3 id="LightGBM和XGBoost的区别？"><a href="#LightGBM和XGBoost的区别？" class="headerlink" title="LightGBM和XGBoost的区别？"></a>LightGBM和XGBoost的区别？</h3><p><a href="https://my.oschina.net/u/4314328/blog/3338894">https://my.oschina.net/u/4314328/blog/3338894</a></p>
<h3 id="LR和GBDT比较，什么情景下GBDT不如LR"><a href="#LR和GBDT比较，什么情景下GBDT不如LR" class="headerlink" title="LR和GBDT比较，什么情景下GBDT不如LR"></a>LR和GBDT比较，什么情景下GBDT不如LR</h3><p>逻辑回归LR是线性模型，可解释性强，很容易并行化，但学习能力有限，需要大量的人工特征工程。GBDT是非线性模型，具有天然的特征组合优势，特征表达能力强，但是树与树之间无法并行训练并且很容易过拟合。</p>
<p>先看一个例子：<br>假设一个二分类问题，label为0和1，特征有100维，如果有1w个样本，但其中只要10个正样本1，而这些样本的特征 f1的值为全为1，而其余9990条样本的f1特征都为0(在高维稀疏的情况下这种情况很常见)。</p>
<ul>
<li>在这种情况下，树模型很容易优化出一个使用f1特征作为重要分裂节点的树，因为这个结点直接能够将训练数据划分的很好，但是当测试的时候，却会发现效果很差，因为这个特征f1只是刚好偶然间跟y拟合到了这个规律，过拟合。</li>
<li>如果采用LR的话，也会出现过拟合的现象，但可以通过正则化更有效的克制。<br>LR 等线性模型的正则项是对权重的惩罚，也就是 W1一旦过大，惩罚就会很大，进一步压缩 W1的值。树模型则不一样，树模型的惩罚项通常为叶子节点数和深度等，而示例，树只需要一个节点就可以完美分割9990和10个样本，一个结点，最终产生的惩罚项很小。</li>
</ul>
<p>在高维稀疏特征的时候：带正则化的线性模型比较不容易对稀疏特征过拟合。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>决策树</tag>
        <tag>GBDT</tag>
        <tag>XGBOOST</tag>
        <tag>Random Forest</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 39 40 216 377 组合-递归</title>
    <url>/2020/09/10/leetcode-combination-39-40-216-377/</url>
    <content><![CDATA[<h3 id="leetcode-四个组合系列题目"><a href="#leetcode-四个组合系列题目" class="headerlink" title="leetcode 四个组合系列题目"></a>leetcode 四个组合系列题目</h3><p>今天来做几个leetcode递归题，重点体会一下递归中的边界条件与递归控制，最后一题是动态规划，使用了从上到下的记忆化递归，可以体会下与递归的区别。题目本身不难，但是要一次ac还是对边界条件有考验，注意复杂度分析。附上题目与 python, c++ 代码。<br><a id="more"></a></p>
<h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></h4><blockquote>
<p>给定一个无重复元素的数组 candidates 和一个目标数 target<br>找出 candidates 中所有可以使数字和为 target 的组合。<br>candidates 中的数字可以无限制重复被选取。<br>1.所有数字（包括 target）都是正整数。<br>2.解集不能包含重复的组合。<br>输入：candidates = [2,3,6,7], target = 7,<br>所求解集为：<br>[[7],[2,2,3]]<br>输入：candidates = [2,3,5], target = 8,<br>所求解集为：<br>[[2,2,2,2],[2,3,3],[3,5]]</p>
</blockquote>
<p>条件：所给数组无重复元素，元素可重复被选取。 要求：不含重复组合的解集。</p>
<ul>
<li>第一想法就是在递归中使用 [0,n) 的for循环，保证元素可重复被选取，然而会产生重复解。比如 candidates = [1,2,3], target = 3, 会产生[1,2] [2,1]的重复解。</li>
<li>第二想法就是用哈希去重，但是涉及到频繁的哈希与数组的转换，不是个好方法</li>
<li>最终方案就是 [index,n) 的for循环，进入下一个递归时输入当前i作为下一个递归的起始index。这样可以保证 1.每个元素可以被重复选取 2.之后index开始的元素不会涵盖之前index开始的解。</li>
<li>ps：还sort(), break 了一下，剪枝下递归。</li>
</ul>
<p>时间复杂度 $O(n 2^n)$，每个数有可能选或不选，n个数递归次数最多就是O(2^n)，把res添加到result中O(n)，最极端的情况就是 $O(n 2^n)$<br>空间复杂度 O(max(n,target)) = 递归空间占用O(max(n,target)) + 递归中额外空间O(1) + 全局空间O(max(n,target))  (ps: res 可理解为全局数组，见C++解法)<br>递归复杂度的详细分析可参见我另一篇blog <strong><a href="https://xinjieinformatik.github.io/2020/09/11/recursion-complexity-analysis/">递归复杂度分析</a></strong><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span>(<span class="params">self, candidates: List[int], target: int</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        n = len(candidates)</span><br><span class="line">        candidates.sort()</span><br><span class="line">        result = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">index, res, target</span>):</span></span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">                result.append(res)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index, n):</span><br><span class="line">                <span class="keyword">if</span> target - candidates[i] &lt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                helper(i, res+[candidates[i]], target-candidates[i])</span><br><span class="line"></span><br><span class="line">        helper(<span class="number">0</span>, [], target)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line">        helper(candidates, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> index, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            result.push_back(res);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target - nums[i] &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            res.push_back(nums[i]);</span><br><span class="line">            helper(nums, i, target-nums[i]);</span><br><span class="line">            res.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></h4><blockquote>
<p>给定一个数组 candidates 和一个目标数 target ，<br>找出 candidates 中所有可以使数字和为 target 的组合。<br>candidates 中的每个数字在每个组合中只能使用一次。<br>1.所有数字（包括目标数）都是正整数。<br>2.解集不能包含重复的组合。<br>输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>所求解集为:<br>[[1, 7],[1, 2, 5],[2, 6],[1, 1, 6]]<br>输入: candidates = [2,5,2,1,2], target = 5,<br>所求解集为:<br>[[1,2,2],[5]]</p>
</blockquote>
<p>输入数组有重复元素，每个元素只能使用一次，输出数组不能包含重复组合 [1,7], [7,1]算重复组合。因此：</p>
<ul>
<li>先sort(), 然后通过candidates[i] != candidates[i-1]排除重复元素带来的影响</li>
<li>i == index or candidates[i] != candidates[i-1], helper(i+1) 保证每个元素只能使用一次(该层递归首个元素可以和前一个元素一样，其他不可以)</li>
<li>和为target后加入到输出数组，能保证无重复组合，可剪枝。</li>
</ul>
<p>时间复杂度 $O(n 2^n)$，每个数有可能选或不选，n个数递归次数最多就是O(2^n)，把res添加到result中O(n)，最极端的情况就是 $O(n 2^n)$<br>空间复杂度 O(max(n,target)) = 递归空间占用O(max(n,target)) + 递归中额外空间O(1) + 全局空间O(max(n,target))<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span>(<span class="params">self, candidates: List[int], target: int</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        candidates.sort()</span><br><span class="line">        n = len(candidates)</span><br><span class="line">        result = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">index, res, target</span>):</span></span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">                result.append(res)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index, n):</span><br><span class="line">                <span class="keyword">if</span> (i == index <span class="keyword">or</span> candidates[i] != candidates[i<span class="number">-1</span>]):</span><br><span class="line">                    temp = target - candidates[i]</span><br><span class="line">                    <span class="keyword">if</span> temp &lt; <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    helper(i+<span class="number">1</span>, res+[candidates[i]], temp)</span><br><span class="line">        helper(<span class="number">0</span>, [], target)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res = &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        helper(candidates, <span class="number">0</span>, target, &amp;result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> index, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; *result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            result-&gt;push_back(res);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == index || nums[i] != nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span> (target-nums[i] &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                res.push_back(nums[i]);</span><br><span class="line">                helper(nums, i+<span class="number">1</span>, target-nums[i], result);</span><br><span class="line">                res.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a href="https://leetcode-cn.com/problems/combination-sum-iii/">216. 组合总和 III</a></h4><blockquote>
<p>找出所有相加之和为 n 的 k 个数的组合。<br>组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。<br>1.所有数字都是正整数。<br>2.解集不能包含重复的组合。<br>输入: k = 3, n = 7<br>输出: [[1,2,4]]<br>输入: k = 3, n = 9<br>输出: [[1,2,6], [1,3,5], [2,3,4]]</p>
</blockquote>
<p>和上两题基本一样，多了个return的条件，k个数的组合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span>(<span class="params">self, k: int, n: int</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">res, index, target</span>):</span></span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span> <span class="keyword">and</span> len(res) == k:</span><br><span class="line">                result.append(res)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> len(res) == k:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index, <span class="number">10</span>):</span><br><span class="line">                <span class="keyword">if</span> target-i &lt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                helper(res+[i], i+<span class="number">1</span>, target-i)</span><br><span class="line"></span><br><span class="line">        result = []</span><br><span class="line">        helper([], <span class="number">1</span>, n)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum3</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        len = k;</span><br><span class="line">        helper(<span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (res.size() == len <span class="keyword">and</span> target == <span class="number">0</span>) &#123;</span><br><span class="line">            result.push_back(res);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res.size() == len) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target - i &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            res.push_back(i);</span><br><span class="line">            helper(i+<span class="number">1</span>, target-i);</span><br><span class="line">            res.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a><a href="https://leetcode-cn.com/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h4><blockquote>
<p>给定一个由正整数组成且不存在重复数字的数组，<br>找出和为给定目标正整数的组合的个数。<br>nums = [1, 2, 3]<br>target = 4<br>所有可能的组合为：<br>(1, 1, 1, 1) (1, 1, 2) (1, 2, 1)<br>(1, 3) (2, 1, 1) (2, 2) (3, 1)<br>请注意，顺序不同的序列被视作不同的组合。<br>因此输出为 7。<br>进阶：<br>如果给定的数组中含有负数会怎么样？<br>问题会产生什么变化？<br>我们需要在题目中添加什么限制来允许负数的出现？</p>
</blockquote>
<p>注意题目 (1,1,2) (1,2,1) 属于不同组合，所以递归函数for范围是[0,n)<br>这题使用动态规划，因为观察可知存在大量重复计算<br>假设target为5，nums=[1,2]，递归树展开如下（同斐波那契）。fib(1),fib(2),fib(3)的组合数之前已经算过了，因此直接记忆化就好了。注意使用记忆化只能得到组合数，不能得到完整的路径，这也是一个能否使用记忆化的快速判别方法。<br><img data-src="/2020/09/10/leetcode-combination-39-40-216-377/fib_example.png" alt="fib_example"></p>
<p>如果数组含有负数，如nums=[-1,1,2,3]，则会有无穷个组合数，要加以限制，比如一个元素只能使用一次。</p>
<p>时间复杂度 $O(target * n)$，状态数 target，每次递归计算量 O(n)。<br>空间复杂度 O(max(n,target)) = 递归空间占用O(max(n,target)) + 递归中额外空间O(1) + 全局空间O(max(n,target))</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span>(<span class="params">self, nums: List[int], target: int</span>) -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line"><span class="meta">        @functools.lru_cache(None)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">res</span>):</span></span><br><span class="line">            <span class="keyword">if</span> res == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                val = res + nums[i]</span><br><span class="line">                <span class="keyword">if</span> val &gt; target:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                ans += helper(val)</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dp;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp.count(target) != <span class="number">0</span>) <span class="keyword">return</span> dp[target];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target - nums[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                res += helper(nums, target-nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[target] = res;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法练习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
        <tag>dfs</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title>递归复杂度分析</title>
    <url>/2020/09/11/recursion-complexity-analysis/</url>
    <content><![CDATA[<h1 id="递归复杂度分析"><a href="#递归复杂度分析" class="headerlink" title="递归复杂度分析"></a>递归复杂度分析</h1><p>递归时间复杂度 和 空间复杂度 分析 往往不那么直观。这篇blog给出通用分析法和主定理两种方法，个人推荐通用分析法，更一般性，更好记。<br><a id="more"></a></p>
<h2 id="通用分析法"><a href="#通用分析法" class="headerlink" title="通用分析法"></a>通用分析法</h2><h3 id="递归时间复杂度分析"><a href="#递归时间复杂度分析" class="headerlink" title="递归时间复杂度分析"></a>递归时间复杂度分析</h3><p>基于递归调用数量与深度两种分析方法，核心是一样的：</p>
<ul>
<li>假设递归调用数量为 R, 递归内每次计算量 O(s), 则时间复杂度 R * O(s)<br>以一个满二叉树为例，递归调用数量指的是 根节点以下的所有孩子数，也就是 2^h - 2, 可写成 O(2^h)。</li>
<li>假设递归调用深度为 h，每层递归内计算总量 O(k), 则时间复杂度 h * O(k)</li>
</ul>
<p>递归通常可以想象成二叉树的结构，画画图对递归分析，哪里加记忆化很有用。<br><img data-src="/2020/09/11/recursion-complexity-analysis/binaryTreeExample.png" alt="binaryTreeExample"></p>
<p>以归并排序和快排为例，分析一下。假设数组长度为 n，基于递归调用深度分析</p>
<ul>
<li><code>归并排序</code>：递归深度 h = logn，每层内递归中的计算总量是 O(n), 因此整体时间复杂度为 O(nlogn)</li>
<li><code>快排</code>：平均情况的递归深度 h = logn，每层内递归中的计算总量是 O(n), 因此整体时间复杂度为 O(nlogn)<br>如果partition中基准pivot选的不好，递归深度退化为 n，每层计算总量依旧是左右两部分一共 O(n), 因此整体时间复杂度为 O(n^2)</li>
</ul>
<h3 id="递归空间复杂度分析"><a href="#递归空间复杂度分析" class="headerlink" title="递归空间复杂度分析"></a>递归空间复杂度分析</h3><p>递归的空间占用分为两部分，递归相关空间 O(h) + O(k) 和 全局空间 O(m)<br>整体空间占用 O(h) + O(k) + O(m), 变量含义如下</p>
<h4 id="递归相关空间"><a href="#递归相关空间" class="headerlink" title="递归相关空间"></a>递归相关空间</h4><p> O(h) + O(k)递归相关空间的占用分为两部分，1.实现递归本身占用空间 O(h)，大小为 O(递归深度) 2.递归中的额外空间占用 O(k)，大小为 O(递归函数中局部变量所占空间)。</p>
<h5 id="实现递归本身占用空间"><a href="#实现递归本身占用空间" class="headerlink" title="实现递归本身占用空间"></a>实现递归本身占用空间</h5><p>由递归直接引起的内存开销，用于跟踪递归函数调用的栈。</p>
<ul>
<li>如果遇到函数，1.初始化函数，开辟新的内存空间，2.实参传入 3.保存当前现场</li>
<li>调用结束后，函数占用的内存空间被释放，1.接受函数的返回值，2.恢复现场，从断点处继续执行</li>
</ul>
<p>想象一个stack，不断把函数的栈压入，到底后才又可以释放，因此stack的空间占用最大为 O(h), 即 O(递归深度)</p>
<h5 id="递归中的额外空间占用"><a href="#递归中的额外空间占用" class="headerlink" title="递归中的额外空间占用"></a>递归中的额外空间占用</h5><ul>
<li>递归函数中局部变量所占空间 O(k)。<br>注意：额外空间占用由运行该递归函数局部变量产生，一旦完成该函数调用，会<code>立刻释放空间</code>，并不会累积。</li>
</ul>
<h4 id="全局空间"><a href="#全局空间" class="headerlink" title="全局空间"></a>全局空间</h4><p>与递归过程没有直接关系的内存空间，通常包括为全局变量分配的空间，如使用记忆化时的dp数组 O(m)。</p>
<h4 id="递归空间复杂度分析实例"><a href="#递归空间复杂度分析实例" class="headerlink" title="递归空间复杂度分析实例"></a>递归空间复杂度分析实例</h4><p>整体空间占用O(h) + O(k) + O(m)</p>
<ul>
<li><code>归并排序</code>：实现递归本身占用空间, 递归深度 h = logn，递归中的额外空间占用 O(n), 全局空间 O(1) 因此整体时间复杂度为 O(logn + n) = O(n)</li>
<li><code>快排</code>：实现递归本身占用空间, 递归深度 h = logn，递归中的额外空间占用 O(1), 全局空间 O(1) 因此整体时间复杂度为 O(logn)</li>
</ul>
<p>由此可见归并排序主存占用大，因此实际使用中对大规模数据有局限</p>
<h3 id="记忆化递归复杂度分析"><a href="#记忆化递归复杂度分析" class="headerlink" title="记忆化递归复杂度分析"></a>记忆化递归复杂度分析</h3><p>如果使用了记忆化, 假设状态数n，使用全局空间 dp数组</p>
<ul>
<li>时间复杂度 n * O(s)，递归次数R 退化至状态数n</li>
<li>空间复杂度 O(logn) + O(k) + O(n)</li>
</ul>
<p>递归次数R 退化至状态数n, 以斐波那契数列为例：<br><img data-src="/2020/09/11/recursion-complexity-analysis/fib_example.png" alt="fib_example"></p>
<p>ps: 尾递归的好处是，它可以避免递归调用期间栈空间开销的累积 O(h)</p>
<h2 id="主定理-时间复杂度分析"><a href="#主定理-时间复杂度分析" class="headerlink" title="主定理 - 时间复杂度分析"></a>主定理 - 时间复杂度分析</h2><p>T(问题规模) = 子问题数 <em> T(子问题规模) + 额外计算<br>T(n) = a </em> T(n/b) + f(n)<br>T(n) = a * T(n/b) + O(n^d)</p>
<ul>
<li>$d &lt; log_b^a, O(n^{log_b^a})$</li>
<li>$d = log_b^a, O(n^d * logn)$</li>
<li>$d &gt; log_b^a, O(n^d)$<br>(log 不标底默认为2)</li>
</ul>
<p>归并排序<br>T(n) = 2T(n/2) + O(n) —&gt; T(n) = O(nlogn)</p>
<p>二分查找<br>T(n) = T(n/2) + O(1) —&gt; T(n) = O(logn)</p>
]]></content>
      <categories>
        <category>算法练习</category>
        <category>复杂度分析</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>复杂度分析</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL基础</title>
    <url>/2020/09/14/sql-base/</url>
    <content><![CDATA[<h1 id="SQL基础"><a href="#SQL基础" class="headerlink" title="SQL基础"></a>SQL基础</h1><p>花1-2天时间，简单把SQL语法过一下吧</p>
<a id="more"></a>
<ol>
<li>SQL 大小写不敏感 select 与 SELECT 是一样的</li>
<li>在末尾加 ; 一次执行多行</li>
</ol>
<h2 id="重要的基础语句"><a href="#重要的基础语句" class="headerlink" title="重要的基础语句"></a>重要的基础语句</h2><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><p>从数据库中选取数据。<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name1, column_name2 <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure></p>
<h3 id="SELECT-DISTINCT"><a href="#SELECT-DISTINCT" class="headerlink" title="SELECT DISTINCT"></a>SELECT DISTINCT</h3><p>返回唯一不同的检索<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> column_name1, column_name2 <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure></p>
<h3 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h3><p>提取满足指定条件的记录<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name1, column_name2 <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_name <span class="keyword">operator</span> <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table1 <span class="keyword">WHERE</span> contry = <span class="string">&quot;CN&quot;</span> <span class="keyword">AND</span> (<span class="keyword">id</span> &gt; <span class="number">100</span> <span class="keyword">OR</span> city = <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> column1 <span class="keyword">FROM</span> table1 <span class="keyword">WHERE</span> column2 <span class="keyword">IS</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table2 <span class="keyword">WHERE</span> contry = <span class="string">&quot;CN&quot;</span> <span class="keyword">OR</span> <span class="keyword">NOT</span> <span class="keyword">id</span> =&lt; <span class="number">10</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table3 <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">42</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table1 <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">BETWEEN</span> <span class="number">15</span> <span class="keyword">AND</span> <span class="number">65</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table1 <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">&#x27;M%&#x27;</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table2 <span class="keyword">WHERE</span> <span class="keyword">name</span> REGEXP <span class="string">&#x27;^[GFs]&#x27;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>%   : 表示多个字值，_ 下划线表示一个字符；</li>
<li>M%  : 为能配符，正则表达式，表示的意思为模糊查询信息为 M 开头的。</li>
<li>%M% : 表示查询包含M的所有内容。</li>
<li>%M_ : 表示查询以M在倒数第二位的所有内容。<br>REGEXP ‘^[GFs]’:  以 G F s 为开始<br>REGEXP ‘^[A-H]’:  以 A 到 H 为开始<br>REGEXP ‘^<sup><a href="#fn_A-H" id="reffn_A-H">A-H</a></sup>‘: 不以 A 到 H 为开始</li>
</ul>
<h3 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h3><p>对结果集按照一个列或者多个列进行排序，默认升序ASC，DESC降序<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> table_name <span class="keyword">ORDER</span> <span class="keyword">BY</span> column_name1, column_name2 <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span>, country <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="INSERT-INTO"><a href="#INSERT-INTO" class="headerlink" title="INSERT INTO"></a>INSERT INTO</h3><p>向表中插入新记录<br>没有指定要插入数据的列名的形式需要列出插入行的每一列数据<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name <span class="keyword">VALUES</span> (values1, value2, value3, ...)</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1, column2, column3) <span class="keyword">VALUES</span> (values1, value2, value3)</span><br></pre></td></tr></table></figure></p>
<h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><p>更新表中已存在的记录<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> column1=value1, column2=value2, ...</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">column</span>=<span class="keyword">value</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Websites <span class="keyword">SET</span> <span class="keyword">id</span>=<span class="number">500</span>, country=<span class="string">&#x27;USA&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">&#x27;dit&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>DELETE 语句用于删除表中的行<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> <span class="keyword">column</span>=<span class="keyword">value</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table1 <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">&#x27;kik&#x27;</span> <span class="keyword">AND</span> country=<span class="string">&#x27;CN&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h3><p>LIMIT 10 用来限制返回条数</p>
<h3 id="为检索结果起别名"><a href="#为检索结果起别名" class="headerlink" title="为检索结果起别名"></a>为检索结果起别名</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">AS</span> alias_name <span class="keyword">FROM</span> table_name;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">AS</span> n, country <span class="keyword">AS</span> c <span class="keyword">FROM</span> Websites;</span><br></pre></td></tr></table></figure>
<p>用 CONCAT 聚合多个列为一列，并起别名为 info<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, <span class="keyword">CONCAT</span>(<span class="keyword">url</span>, <span class="string">&#x27;, &#x27;</span>, <span class="keyword">id</span>, <span class="string">&#x27;, &#x27;</span>, country) <span class="keyword">AS</span> info <span class="keyword">FROM</span> table1;</span><br></pre></td></tr></table></figure></p>
<h3 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h3><p>JOIN 联合多个表，根据关系查询结果</p>
<h4 id="INNER-JOIN"><a href="#INNER-JOIN" class="headerlink" title="INNER JOIN"></a>INNER JOIN</h4><p>table1与table2应至少有一列的内容完全一样，用于关联匹配<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> table1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1.column_name=table2.column_name;</span><br></pre></td></tr></table></figure><br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> (table1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1.column_name=table2.column_name) <span class="keyword">INNER</span> <span class="keyword">JOIN</span> table3 <span class="keyword">ON</span> table1.column_name=table3.column_name;</span><br></pre></td></tr></table></figure></p>
<p>我们先考虑用 SELECT 实现 同样的筛选逻辑<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> persons.firstname, orders.orderNo <span class="keyword">FROM</span> persons <span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> persons.PID = Orders.PID;</span><br></pre></td></tr></table></figure><br>同样的逻辑 JOIN (INNER JOIN) 实现<br>之后会分析 JOIN 与 SELECT 实现和性能上的差异 TODO<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> persons.firstname, orders.orderNo <span class="keyword">FROM</span> persons <span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> persons.PID=orders.PID;</span><br></pre></td></tr></table></figure></p>
<h4 id="LEFT-JOIN"><a href="#LEFT-JOIN" class="headerlink" title="LEFT JOIN"></a>LEFT JOIN</h4><p>SELECT WHERE 和 INNER JOIN 查询 tables 之间均有的行， LEFT JOIN 在此基础之上，还会返回 table1 中有，但是其他 tables 中没有匹配项的行，检索的结果中来自其他tables的列，为 NULL<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> table1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1.column_name=table2.column_name;</span><br></pre></td></tr></table></figure></p>
<h4 id="RIGHT-JOIN"><a href="#RIGHT-JOIN" class="headerlink" title="RIGHT JOIN"></a>RIGHT JOIN</h4><p>双表时和 LEFT JOIN 其实是一样的，table1 table2 位置不一样。多表时，会返回其他 tables 的未匹配行<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> table1 <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1.column_name=table2.column_name;</span><br></pre></td></tr></table></figure></p>
<h4 id="FULL-JOIN"><a href="#FULL-JOIN" class="headerlink" title="FULL JOIN"></a>FULL JOIN</h4><p>左右表中的未匹配行都会输出<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> table1 <span class="keyword">FULL</span> <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1.column_name=table2.column_name;</span><br></pre></td></tr></table></figure></p>
<h3 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h3><p>合并多个 SELECT 语句的行结果集 (注意，多个 SELECT 语句之间列数目要一样，数据类型要一样)<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1 <span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> column1 <span class="keyword">FROM</span> table3</span><br></pre></td></tr></table></figure></p>
<h3 id="SELECT-INTO"><a href="#SELECT-INTO" class="headerlink" title="SELECT INTO"></a>SELECT INTO</h3><p>从一个表中选取数据，然后把数据插入另一个表中, 常用于创建表的备份复件<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">INTO</span> new_table <span class="keyword">FROM</span> old_table;</span><br></pre></td></tr></table></figure><br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, <span class="keyword">id</span> <span class="keyword">INTO</span> new_table <span class="keyword">IN</span> <span class="string">&quot;backup.mdb&quot;</span> <span class="keyword">FROM</span> old_table;</span><br></pre></td></tr></table></figure></p>
<h3 id="CREATE-TABLE"><a href="#CREATE-TABLE" class="headerlink" title="CREATE TABLE"></a>CREATE TABLE</h3><p>创建数据库中的表<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table1</span><br><span class="line">(</span><br><span class="line">  column1 <span class="built_in">varchar</span>(<span class="number">10</span>),</span><br><span class="line">  column2 <span class="built_in">int</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>约束用于限制加入表的数据的类型。可以在创建表时规定约束（通过 CREATE TABLE 语句），或者在表创建之后也可以（通过 ALTER TABLE 语句）。</p>
<h4 id="NOT-NULL-约束"><a href="#NOT-NULL-约束" class="headerlink" title="NOT NULL 约束"></a>NOT NULL 约束</h4><p>强制列不接受 NULL 值<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Persons</span><br><span class="line">(</span><br><span class="line">Id_P <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">LastName <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h4 id="UNIQUE-约束"><a href="#UNIQUE-约束" class="headerlink" title="UNIQUE 约束"></a>UNIQUE 约束</h4><p>唯一标识数据库表中的每条记录<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Persons</span><br><span class="line">(</span><br><span class="line">Id_P <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">LastName <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">UNIQUE</span> (Id_P)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Persons</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> (Id_P);</span><br></pre></td></tr></table></figure></p>
<h4 id="PRIMARY-KEY-约束"><a href="#PRIMARY-KEY-约束" class="headerlink" title="PRIMARY KEY 约束"></a>PRIMARY KEY 约束</h4><p>唯一标识数据库表中的每条记录。主键必须包含唯一的值, 主键列不能包含 NULL 值, 每个表都应该有一个主键，并且每个表只能有一个主键。<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Persons</span><br><span class="line">(</span><br><span class="line">Id_P <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (Id_P)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h4 id="FOREIGN-KEY"><a href="#FOREIGN-KEY" class="headerlink" title="FOREIGN KEY"></a>FOREIGN KEY</h4><p>FOREIGN KEY 指向另一个表中的 PRIMARY KEY<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line">(</span><br><span class="line">Id_O <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">OrderNo <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">Id_P <span class="built_in">int</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (Id_O),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Id_P) <span class="keyword">REFERENCES</span> Persons(Id_P)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (Id_P) <span class="keyword">REFERENCES</span> Persons(Id_P);</span><br></pre></td></tr></table></figure></p>
<h4 id="CHECK-约束"><a href="#CHECK-约束" class="headerlink" title="CHECK 约束"></a>CHECK 约束</h4><p>限制列中的值的范围<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Persons</span><br><span class="line">(</span><br><span class="line">Id_P <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">CHECK</span> (Id_P&gt;<span class="number">0</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Persons</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CHECK</span> (Id_P&gt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="DEFAULT-约束"><a href="#DEFAULT-约束" class="headerlink" title="DEFAULT 约束"></a>DEFAULT 约束</h4><p>向列中插入默认值<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Persons</span><br><span class="line">(</span><br><span class="line">Id_P <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">City <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;Sandnes&#x27;</span></span><br><span class="line">OrderDate <span class="built_in">date</span> <span class="keyword">DEFAULT</span> <span class="keyword">GETDATE</span>()</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="CREATE-INDEX"><a href="#CREATE-INDEX" class="headerlink" title="CREATE INDEX"></a>CREATE INDEX</h3><p>在表中创建索引, 索引使数据库应用程序可以更快地查找数据, 无法看到索引，它们只能被用来加速搜索/查询。<br>CREATE INDEX<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> PersonIndex <span class="keyword">ON</span> Person (<span class="keyword">id</span>, FirstName);</span><br></pre></td></tr></table></figure><br>CREATE UNIQUE INDEX<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> PersonIndex <span class="keyword">ON</span> Person (<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="DROP"><a href="#DROP" class="headerlink" title="DROP"></a>DROP</h3><p>删除索引、表和数据库</p>
<h3 id="ALTER-TABLE"><a href="#ALTER-TABLE" class="headerlink" title="ALTER TABLE"></a>ALTER TABLE</h3><p>在已有的表中添加、修改或删除列<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> column_name datatype</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> datatype0 datatype1;</span><br></pre></td></tr></table></figure></p>
<h3 id="AUTO-INCREMENT-字段"><a href="#AUTO-INCREMENT-字段" class="headerlink" title="AUTO INCREMENT 字段"></a>AUTO INCREMENT 字段</h3><p>每次插入新记录时，自动地创建主键字段的值。<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Persons</span><br><span class="line">(</span><br><span class="line">P_Id <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">LastName <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (P_Id);</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h3 id="视图-VIEW"><a href="#视图-VIEW" class="headerlink" title="视图 VIEW"></a>视图 VIEW</h3><p>视图是基于 SQL 语句的结果集的可视化的表。注意更新视图的数据不会改变原数据。</p>
<p>CREATE VIEW<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> condition;</span><br></pre></td></tr></table></figure><br>查询 VIEW<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> view_name;</span><br></pre></td></tr></table></figure></p>
<p>DROP VIEW<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> view_name;</span><br></pre></td></tr></table></figure></p>
<h3 id="MySQL-数据类型"><a href="#MySQL-数据类型" class="headerlink" title="MySQL 数据类型"></a>MySQL 数据类型</h3><p><a href="https://dev.mysql.com/doc/refman/8.0/en/data-types.html">https://dev.mysql.com/doc/refman/8.0/en/data-types.html</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/">MySQL官方文档</a></li>
<li><a href="https://www.runoob.com/sql/">菜鸟教程SQL</a></li>
<li><a href="https://www.w3school.com.cn/sql/index.asp">w3school-SQL</a></li>
</ul>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL基础</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵的搜索专题</title>
    <url>/2020/09/13/matrix-dfs/</url>
    <content><![CDATA[<h1 id="矩阵的搜索专题"><a href="#矩阵的搜索专题" class="headerlink" title="矩阵的搜索专题"></a>矩阵的搜索专题</h1><p>在二维或多维矩阵上做广度或者深度优先搜索算是比较经典的题了，但是因为不熟练，往往写的时间会耽搁，这里总结一下几道常见的矩阵dfs bfs搜索的题目，做个总结。</p>
<a id="more"></a>
<h2 id="二维矩阵的最短路径"><a href="#二维矩阵的最短路径" class="headerlink" title="二维矩阵的最短路径"></a><a href>二维矩阵的最短路径</a></h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">题目：给出n*n矩阵，第二行指定起始,终止坐标，求最短路径，只用# @是障碍物</span><br><span class="line">7</span><br><span class="line">0 0 0 3</span><br><span class="line">*5#++B+</span><br><span class="line">55.++++</span><br><span class="line">###$+++</span><br><span class="line">++$@$++</span><br><span class="line">+++$$++</span><br><span class="line">A++++##</span><br><span class="line">+++++#+</span><br></pre></td></tr></table></figure>
<p>这是一次笔试中遇到的题目，第一反应不知道怎么想的，居然用dfs。教训！</p>
<ul>
<li><strong>最短路径请用bfs</strong>，用dfs相当于递归遍历能到达终点的所有路径，选最短，太慢了。</li>
<li>矩阵的递归与二叉树的递归不同，二叉树没有回头路，矩阵要将走过的路设为visited，避免走回头路，递归退出的时候，要将visited设回0，当然也可以修改遍历的matrix，使得无法走回头路</li>
<li>时间复杂度 $O(N M 3^L)$ 这是一个很宽裕的上限，最坏情况每个都进入搜索，路径长度L，因为不走回头路，所以每个节点有3个方向选择（第一个节点4个）。但是如果求最短路径，bfs会更快搜到目标并退出，用bfs。</li>
<li>使用dfs注意矩阵的vis与复原，使用bfs注意保证不走回头路也要使用vis数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line">si, sj, ei, ej = list(map(int, input().split()))</span><br><span class="line">grid = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    grid.append(input())</span><br><span class="line"></span><br><span class="line">oriens = [(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">0</span>,<span class="number">-1</span>)]</span><br><span class="line">vis = [[<span class="number">0</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i, j</span>):</span></span><br><span class="line">    <span class="keyword">if</span> i == ei <span class="keyword">and</span> j == ej:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    res = float(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> orien <span class="keyword">in</span> oriens:</span><br><span class="line">        nxt_i, nxt_j = i+orien[<span class="number">0</span>], j+orien[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> nxt_i &lt; <span class="number">0</span> <span class="keyword">or</span> nxt_i &gt;= n <span class="keyword">or</span> nxt_j &lt; <span class="number">0</span> <span class="keyword">or</span> nxt_j &gt;= n:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> grid[nxt_i][nxt_j] == <span class="string">&#x27;#&#x27;</span> <span class="keyword">or</span> grid[nxt_i][nxt_j] == <span class="string">&#x27;@&#x27;</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> vis[nxt_i][nxt_j]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        vis[nxt_i][nxt_j] = <span class="number">1</span></span><br><span class="line">        ans = dfs(nxt_i, nxt_j) + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 记得要用vis，退出时设为0</span></span><br><span class="line">        vis[nxt_i][nxt_j] = <span class="number">0</span></span><br><span class="line">        res = min(res, ans)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">vis = [[<span class="number">0</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span>():</span></span><br><span class="line">    queue = deque([[si,sj,<span class="number">0</span>]])</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        i, j, step = queue.pop()</span><br><span class="line">        <span class="keyword">for</span> orien <span class="keyword">in</span> oriens:</span><br><span class="line">            nxt_i, nxt_j = i + orien[<span class="number">0</span>], j + orien[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> nxt_i &lt; <span class="number">0</span> <span class="keyword">or</span> nxt_i &gt;= n <span class="keyword">or</span> nxt_j &lt; <span class="number">0</span> <span class="keyword">or</span> nxt_j &gt;= n:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> grid[nxt_i][nxt_j] == <span class="string">&#x27;#&#x27;</span> <span class="keyword">or</span> grid[nxt_i][nxt_j] == <span class="string">&#x27;@&#x27;</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> vis[nxt_i][nxt_j]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nxt_i == ei <span class="keyword">and</span> nxt_j == ej:</span><br><span class="line">                <span class="keyword">return</span> step+<span class="number">1</span></span><br><span class="line">            vis[nxt_i][nxt_j] = <span class="number">1</span></span><br><span class="line">            queue.appendleft((nxt_i, nxt_j, step+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">vis[si][sj] = <span class="number">1</span></span><br><span class="line">ans = dfs(si, sj)</span><br><span class="line">print(ans)</span><br><span class="line"></span><br><span class="line">ans = bfs()</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure>
<h2 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索</a></h2><blockquote>
<p>board =<br>[[‘A’,’B’,’C’,’E’],<br>[‘S’,’F’,’C’,’S’],<br>[‘A’,’D’,’E’,’E’]]<br>给定 word = “ABCCED”, 返回 true<br>给定 word = “SEE”, 返回 true<br>给定 word = “ABCB”, 返回 false</p>
</blockquote>
<p>时间复杂度 $O(N M 3^L)$, 首先遍历二维矩阵，遇到字母与首字母相同，就dfs开始搜索，注意凡是进入dfs前，将vis置1，退出置0，首次进入dfs也不例外。为什么这题可以dfs呢？因为不是最短路径，单词的路线是线性的，不需要递归多个路径选最短，在这种情况下，其实dfs是更快的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span>(<span class="params">self, board: List[List[str]], word: str</span>) -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i, j, k</span>):</span></span><br><span class="line">            <span class="keyword">if</span> k == len(word):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            char = board[i][j]</span><br><span class="line">            board[i][j] = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> orien <span class="keyword">in</span> oriens:</span><br><span class="line">                nxt_i = orien[<span class="number">0</span>] + i</span><br><span class="line">                nxt_j = orien[<span class="number">1</span>] + j</span><br><span class="line">                <span class="keyword">if</span> nxt_i &lt; <span class="number">0</span> <span class="keyword">or</span> nxt_i &gt;= n:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> nxt_j &lt; <span class="number">0</span> <span class="keyword">or</span> nxt_j &gt;= m:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> board[nxt_i][nxt_j] == word[k]:</span><br><span class="line">                    <span class="keyword">if</span> dfs(nxt_i, nxt_j, k+<span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            board[i][j] = char</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        oriens = [(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">-1</span>),(<span class="number">0</span>,<span class="number">1</span>)]</span><br><span class="line">        n = len(board)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        m = len(board[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == word[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">if</span> dfs(i, j, <span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; oriens &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = board.size();</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == word[<span class="number">0</span>]) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span> (helper(board, word, <span class="number">1</span>, i, j)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    board[i][j] = word[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="built_in">string</span> &amp;word, <span class="keyword">int</span> index, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == word.size()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;orien : oriens) &#123;</span><br><span class="line">            <span class="keyword">int</span> nxt_i = i + orien[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> nxt_j = j + orien[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nxt_i &lt; <span class="number">0</span> || nxt_i &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (nxt_j &lt; <span class="number">0</span> || nxt_j &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (word[index] != board[nxt_i][nxt_j]) <span class="keyword">continue</span>;</span><br><span class="line">            board[nxt_i][nxt_j] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (helper(board, word, index+<span class="number">1</span>, nxt_i, nxt_j)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            board[nxt_i][nxt_j] = word[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></h2><blockquote>
<p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。假设该网格的四条边均被水包围。<br>输入:<br>[<br>[‘1’,’1’,’1’,’1’,’0’],<br>[‘1’,’1’,’0’,’1’,’0’],<br>[‘1’,’1’,’0’,’0’,’0’],<br>[‘0’,’0’,’0’,’0’,’0’]<br>]<br>输出: 1</p>
</blockquote>
<p>这一题也是典型的dfs搜素题，但是注意这与上面递归搜索不同，时间复杂度上限 O(nm)，因为对应遍历过的元素，不会再次进入，vis设为1之后不用置0，这是与上面最明显的区别。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span>(<span class="params">self, grid: List[List[str]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">i, j</span>):</span></span><br><span class="line">            queue = deque([(i,j)])</span><br><span class="line">            grid[i][j] = <span class="string">&quot;0&quot;</span></span><br><span class="line">            oriens = [(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">0</span>,<span class="number">-1</span>)]</span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                    row, col = queue.pop()</span><br><span class="line">                    <span class="keyword">for</span> orien <span class="keyword">in</span> oriens:</span><br><span class="line">                        nxt_row, nxt_col = row+orien[<span class="number">0</span>], col+orien[<span class="number">1</span>]</span><br><span class="line">                        <span class="keyword">if</span> nxt_row &lt; <span class="number">0</span> <span class="keyword">or</span> nxt_row &gt;= n <span class="keyword">or</span> nxt_col &lt; <span class="number">0</span> <span class="keyword">or</span> nxt_col &gt;= m:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                        <span class="keyword">if</span> grid[nxt_row][nxt_col] == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                        queue.appendleft((nxt_row, nxt_col))</span><br><span class="line">                        grid[nxt_row][nxt_col] = <span class="string">&quot;0&quot;</span></span><br><span class="line"></span><br><span class="line">        n = len(grid)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m = len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    bfs(i, j)</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; oriens &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> cnt;</span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;orien : oriens) &#123;</span><br><span class="line">            <span class="keyword">int</span> nxt_i = i + orien[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> nxt_j = j + orien[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nxt_i &lt; <span class="number">0</span> || nxt_i &gt;= grid.size() || nxt_j &lt; <span class="number">0</span> || nxt_j &gt;= grid[<span class="number">0</span>].size()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (grid[nxt_i][nxt_j] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            grid[nxt_i][nxt_j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            dfs(grid, nxt_i, nxt_j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="1254-统计封闭岛屿的数目"><a href="#1254-统计封闭岛屿的数目" class="headerlink" title="1254. 统计封闭岛屿的数目"></a><a href="https://leetcode-cn.com/problems/number-of-closed-islands/">1254. 统计封闭岛屿的数目</a></h2><blockquote>
<p>有一个二维矩阵 grid，陆地记号为0,水域记号为1。<br>如果一座岛屿 完全 由水域包围，即陆地边缘上下左右所有相邻区域都是水域，那么我们将其称为 「封闭岛屿」。如果该陆地处于边界，不算封闭岛屿。</p>
</blockquote>
<p>这一题和上一题基本一样，但是边界处陆地不属于封闭岛屿，所以需要前处理（c++版本），或者在递归里判断是否走到了边界（python版本）。更推荐前处理，将边界陆地先走一遍置为水域1，思路更模块化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closedIsland</span>(<span class="params">self, grid: List[List[int]]</span>) -&gt; int:</span></span><br><span class="line">        n = len(grid)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m = len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        oriens = [(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">-1</span>),(<span class="number">0</span>,<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i, j</span>):</span></span><br><span class="line">            <span class="keyword">for</span> orien <span class="keyword">in</span> oriens:</span><br><span class="line">                nxt_i, nxt_j = i+orien[<span class="number">0</span>], j+orien[<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> nxt_i &lt; <span class="number">0</span> <span class="keyword">or</span> nxt_i &gt;= n <span class="keyword">or</span> nxt_j &lt; <span class="number">0</span> <span class="keyword">or</span> nxt_j &gt;= m:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> nxt_i == <span class="number">0</span> <span class="keyword">or</span> nxt_i == n<span class="number">-1</span> <span class="keyword">or</span> nxt_j == <span class="number">0</span> <span class="keyword">or</span> nxt_j == m<span class="number">-1</span>:</span><br><span class="line">                    <span class="keyword">if</span> grid[nxt_i][nxt_j] == <span class="number">0</span>:</span><br><span class="line">                        self.flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> grid[nxt_i][nxt_j] == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                grid[nxt_i][nxt_j] = <span class="number">1</span></span><br><span class="line">                dfs(nxt_i, nxt_j)</span><br><span class="line"></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> i == n<span class="number">-1</span> <span class="keyword">or</span> j == <span class="number">0</span> <span class="keyword">or</span> j == m<span class="number">-1</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    self.flag = <span class="literal">True</span></span><br><span class="line">                    grid[i][j] = <span class="number">1</span></span><br><span class="line">                    dfs(i, j)</span><br><span class="line">                    <span class="keyword">if</span> self.flag:</span><br><span class="line">                        cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; oriens &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closedIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.empty()) <span class="keyword">return</span> cnt;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size();</span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">// 把边缘的陆地变为水域</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((i == <span class="number">0</span> || i == n<span class="number">-1</span> || j == <span class="number">0</span> || j == m<span class="number">-1</span>) &amp;&amp; grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    grid[i][j] = <span class="number">1</span>;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    grid[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;orien : oriens) &#123;</span><br><span class="line">            <span class="keyword">int</span> nxt_i = i + orien.first;</span><br><span class="line">            <span class="keyword">int</span> nxt_j = j + orien.second;</span><br><span class="line">            <span class="keyword">if</span> (nxt_i &lt; <span class="number">0</span> || nxt_i &gt;= grid.size() || nxt_j &lt; <span class="number">0</span> || nxt_j &gt;= grid[<span class="number">0</span>].size()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (grid[nxt_i][nxt_j] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            grid[nxt_i][nxt_j] = <span class="number">1</span>;</span><br><span class="line">            dfs(grid, nxt_i, nxt_j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a><a href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域</a></h2><blockquote>
<p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。<br>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。<br>X X X X<br>X O O X<br>X X O X<br>X O X X<br>变为<br>X X X X<br>X X X X<br>X X X X<br>X O X X</p>
</blockquote>
<p>其实这个和<a href="https://leetcode-cn.com/problems/number-of-closed-islands/">1254. 统计封闭岛屿的数目</a>完全一样，预处理把边界的O变成B（或者记录坐标即可），dfs二维矩阵X-&gt;O，再把O复原成O。 或者在搜索中记录路径index，检测是否遇到边界，没有的话该搜索退出后，把路径上的O变为X。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">self, board: List[List[str]]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        height = len(board)</span><br><span class="line">        <span class="keyword">if</span> height==<span class="number">0</span>: <span class="keyword">return</span> board</span><br><span class="line">        width = len(board[<span class="number">0</span>])</span><br><span class="line">        directions = [(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">0</span>,<span class="number">-1</span>)]</span><br><span class="line">        visited = set()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i,j</span>):</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> i == height<span class="number">-1</span> <span class="keyword">or</span> j == <span class="number">0</span> <span class="keyword">or</span> j == width<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span>, <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> (i,j) <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span>, <span class="literal">None</span></span><br><span class="line">            queue = [(i,j)]</span><br><span class="line">            visited.add((i,j))</span><br><span class="line">            result = [(i,j)]</span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                top = queue.pop()</span><br><span class="line">                <span class="keyword">for</span> direction <span class="keyword">in</span> directions:</span><br><span class="line">                    row = top[<span class="number">0</span>] + direction[<span class="number">0</span>]</span><br><span class="line">                    col = top[<span class="number">1</span>] + direction[<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> row&lt;<span class="number">0</span> <span class="keyword">or</span> row&gt;=height <span class="keyword">or</span> col&lt;<span class="number">0</span> <span class="keyword">or</span> col&gt;=width:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> (row,col) <span class="keyword">not</span> <span class="keyword">in</span> visited <span class="keyword">and</span> board[row][col] == <span class="string">&quot;O&quot;</span>:</span><br><span class="line">                        <span class="keyword">if</span> row == <span class="number">0</span> <span class="keyword">or</span> row == height<span class="number">-1</span> <span class="keyword">or</span> col == <span class="number">0</span> <span class="keyword">or</span> col == width<span class="number">-1</span>:</span><br><span class="line">                            flag = <span class="literal">False</span></span><br><span class="line">                        queue.append((row,col))</span><br><span class="line">                        visited.add((row,col))</span><br><span class="line">                        result.append((row,col))</span><br><span class="line">            <span class="keyword">return</span> flag, result</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(height):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(width):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&quot;O&quot;</span>:</span><br><span class="line">                    flag, result = dfs(i,j)</span><br><span class="line">                    <span class="keyword">if</span> flag:</span><br><span class="line">                        <span class="keyword">for</span> item <span class="keyword">in</span> result:</span><br><span class="line">                            row, col = item</span><br><span class="line">                            board[row][col] = <span class="string">&quot;X&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="864-获取所有钥匙的最短路径"><a href="#864-获取所有钥匙的最短路径" class="headerlink" title="864. 获取所有钥匙的最短路径"></a><a href="https://leetcode-cn.com/problems/shortest-path-to-get-all-keys/">864. 获取所有钥匙的最短路径</a></h2><blockquote>
<p>给定一个二维网格 grid。 “.” 代表一个空房间， “#” 代表一堵墙， “@” 是起点，（”a”, “b”, …）代表钥匙，（”A”, “B”, …）代表锁。<br>我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。<br>假设 K 为钥匙/锁的个数，且满足 1 &lt;= K &lt;= 6，字母表中的前 K 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。<br>返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 -1 。</p>
</blockquote>
<p>三维的bfs，求最短路径<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestPathAllKeys</span>(<span class="params">self, grid: List[str]</span>) -&gt; int:</span></span><br><span class="line">        mapping = &#123;<span class="string">&quot;a&quot;</span>:<span class="number">0</span>, <span class="string">&quot;b&quot;</span>:<span class="number">1</span>, <span class="string">&quot;c&quot;</span>:<span class="number">2</span>, <span class="string">&quot;d&quot;</span>:<span class="number">3</span>, <span class="string">&quot;e&quot;</span>:<span class="number">4</span>, <span class="string">&quot;f&quot;</span>:<span class="number">5</span>&#125;</span><br><span class="line">        n = len(grid)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        m = len(grid[<span class="number">0</span>])</span><br><span class="line">        nk = <span class="number">0</span></span><br><span class="line">        start = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                cell = grid[i][j]</span><br><span class="line">                <span class="keyword">if</span> cell.islower():</span><br><span class="line">                    nk |= (<span class="number">1</span>&lt;&lt;mapping[cell])</span><br><span class="line">                <span class="keyword">if</span> cell == <span class="string">&quot;@&quot;</span>:</span><br><span class="line">                    start = [i, j]</span><br><span class="line">        visited = [[[<span class="number">0</span> <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>&lt;&lt;len(mapping))] <span class="keyword">for</span> i <span class="keyword">in</span> range(m)] <span class="keyword">for</span> j <span class="keyword">in</span> range(n)]</span><br><span class="line">        row, col, k = start[<span class="number">0</span>], start[<span class="number">1</span>], <span class="number">0</span></span><br><span class="line">        queue = collections.deque([(row, col, k)])</span><br><span class="line">        orients = [[<span class="number">-1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">-1</span>],[<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">        level = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                row, col, k = queue.pop()</span><br><span class="line">                <span class="comment"># print(grid[row][col])</span></span><br><span class="line">                <span class="keyword">for</span> orient <span class="keyword">in</span> orients:</span><br><span class="line">                    nxt_row, nxt_col = row + orient[<span class="number">0</span>], col + orient[<span class="number">1</span>]</span><br><span class="line">                    nxt_k = k</span><br><span class="line">                    <span class="comment"># 越界</span></span><br><span class="line">                    <span class="keyword">if</span> nxt_row&lt;<span class="number">0</span> <span class="keyword">or</span> nxt_row&gt;=n <span class="keyword">or</span> nxt_col&lt;<span class="number">0</span> <span class="keyword">or</span> nxt_col&gt;=m:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    cell = grid[nxt_row][nxt_col]</span><br><span class="line">                    <span class="comment"># 该状态访问过</span></span><br><span class="line">                    <span class="keyword">if</span> visited[nxt_row][nxt_col][nxt_k]:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment"># 遇到墙</span></span><br><span class="line">                    <span class="keyword">if</span> cell == <span class="string">&quot;#&quot;</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment"># 遇到门,没相应的钥匙</span></span><br><span class="line">                    <span class="keyword">if</span> cell.isupper() <span class="keyword">and</span> (<span class="number">1</span>&lt;&lt;mapping[cell.lower()]) &amp; nxt_k == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment"># 遇到钥匙</span></span><br><span class="line">                    <span class="keyword">if</span> cell.islower():</span><br><span class="line">                        nxt_k |= (<span class="number">1</span>&lt;&lt;mapping[cell]) <span class="comment"># 重复没关系</span></span><br><span class="line">                        <span class="keyword">if</span> nxt_k == nk:</span><br><span class="line">                            <span class="keyword">return</span> level</span><br><span class="line"></span><br><span class="line">                    visited[nxt_row][nxt_col][nxt_k] = <span class="number">1</span></span><br><span class="line">                    queue.appendleft((nxt_row, nxt_col, nxt_k))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法练习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
</search>
