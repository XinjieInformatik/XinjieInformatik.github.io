<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>递归复杂度分析</title>
    <url>/2020/09/11/recursion-complexity-analysis/</url>
    <content><![CDATA[<h1 id="递归复杂度分析"><a href="#递归复杂度分析" class="headerlink" title="递归复杂度分析"></a>递归复杂度分析</h1><p>递归时间复杂度 和 空间复杂度 分析 往往不那么直观。这篇blog给出通用分析法和主定理两种方法，个人推荐通用分析法，更一般性，更好记。<br><a id="more"></a></p>
<h2 id="通用分析法"><a href="#通用分析法" class="headerlink" title="通用分析法"></a>通用分析法</h2><h3 id="递归时间复杂度分析"><a href="#递归时间复杂度分析" class="headerlink" title="递归时间复杂度分析"></a>递归时间复杂度分析</h3><p>基于递归调用数量与深度两种分析方法，核心是一样的：</p>
<ul>
<li>假设递归调用数量为 R, 递归内每次计算量 O(s), 则时间复杂度 R * O(s)<br>以一个满二叉树为例，递归调用数量指的是 根节点以下的所有孩子数，也就是 2^h - 2, 可写成 O(2^h)。</li>
<li>假设递归调用深度为 h，每层递归内计算总量 O(k), 则时间复杂度 h * O(k)</li>
</ul>
<p>递归通常可以想象成二叉树的结构，画画图对递归分析，哪里加记忆化很有用。<br><img data-src="/2020/09/11/recursion-complexity-analysis/binaryTreeExample.png" alt="binaryTreeExample"></p>
<p>以归并排序和快排为例，分析一下。假设数组长度为 n，基于递归调用深度分析</p>
<ul>
<li><code>归并排序</code>：递归深度 h = logn，每层内递归中的计算总量是 O(n), 因此整体时间复杂度为 O(nlogn)</li>
<li><code>快排</code>：平均情况的递归深度 h = logn，每层内递归中的计算总量是 O(n), 因此整体时间复杂度为 O(nlogn)<br>如果partition中基准pivot选的不好，递归深度退化为 n，每层计算总量依旧是左右两部分一共 O(n), 因此整体时间复杂度为 O(n^2)</li>
</ul>
<h3 id="递归空间复杂度分析"><a href="#递归空间复杂度分析" class="headerlink" title="递归空间复杂度分析"></a>递归空间复杂度分析</h3><p>递归的空间占用分为两部分，递归相关空间 O(h) + O(k) 和 全局空间 O(m)<br>整体空间占用 O(h) + O(k) + O(m), 变量含义如下</p>
<h4 id="递归相关空间"><a href="#递归相关空间" class="headerlink" title="递归相关空间"></a>递归相关空间</h4><p> O(h) + O(k)递归相关空间的占用分为两部分，1.实现递归本身占用空间 O(h)，大小为 O(递归深度) 2.递归中的额外空间占用 O(k)，大小为 O(递归函数中局部变量所占空间)。</p>
<h5 id="实现递归本身占用空间"><a href="#实现递归本身占用空间" class="headerlink" title="实现递归本身占用空间"></a>实现递归本身占用空间</h5><p>由递归直接引起的内存开销，用于跟踪递归函数调用的栈。</p>
<ul>
<li>如果遇到函数，1.初始化函数，开辟新的内存空间，2.实参传入 3.保存当前现场</li>
<li>调用结束后，函数占用的内存空间被释放，1.接受函数的返回值，2.恢复现场，从断点处继续执行</li>
</ul>
<p>想象一个stack，不断把函数的栈压入，到底后才又可以释放，因此stack的空间占用最大为 O(h), 即 O(递归深度)</p>
<h5 id="递归中的额外空间占用"><a href="#递归中的额外空间占用" class="headerlink" title="递归中的额外空间占用"></a>递归中的额外空间占用</h5><ul>
<li>递归函数中局部变量所占空间 O(k)。<br>注意：额外空间占用由运行该递归函数局部变量产生，一旦完成该函数调用，会<code>立刻释放空间</code>，并不会累积。</li>
</ul>
<h4 id="全局空间"><a href="#全局空间" class="headerlink" title="全局空间"></a>全局空间</h4><p>与递归过程没有直接关系的内存空间，通常包括为全局变量分配的空间，如使用记忆化时的dp数组 O(m)。</p>
<h4 id="递归空间复杂度分析实例"><a href="#递归空间复杂度分析实例" class="headerlink" title="递归空间复杂度分析实例"></a>递归空间复杂度分析实例</h4><p>整体空间占用O(h) + O(k) + O(m)</p>
<ul>
<li><code>归并排序</code>：实现递归本身占用空间, 递归深度 h = logn，递归中的额外空间占用 O(n), 全局空间 O(1) 因此整体时间复杂度为 O(logn + n) = O(n)</li>
<li><code>快排</code>：实现递归本身占用空间, 递归深度 h = logn，递归中的额外空间占用 O(1), 全局空间 O(1) 因此整体时间复杂度为 O(logn)</li>
</ul>
<p>由此可见归并排序主存占用大，因此实际使用中对大规模数据有局限</p>
<h3 id="记忆化递归复杂度分析"><a href="#记忆化递归复杂度分析" class="headerlink" title="记忆化递归复杂度分析"></a>记忆化递归复杂度分析</h3><p>如果使用了记忆化, 假设状态数n，使用全局空间 dp数组</p>
<ul>
<li>时间复杂度 n * O(s)，递归次数R 退化至状态数n</li>
<li>空间复杂度 O(logn) + O(k) + O(n)</li>
</ul>
<p>递归次数R 退化至状态数n, 以斐波那契数列为例：<br><img data-src="/2020/09/11/recursion-complexity-analysis/fib_example.png" alt="fib_example"></p>
<p>ps: 尾递归的好处是，它可以避免递归调用期间栈空间开销的累积 O(h)</p>
<h2 id="主定理-时间复杂度分析"><a href="#主定理-时间复杂度分析" class="headerlink" title="主定理 - 时间复杂度分析"></a>主定理 - 时间复杂度分析</h2><p>T(问题规模) = 子问题数 <em> T(子问题规模) + 额外计算<br>T(n) = a </em> T(n/b) + f(n)<br>T(n) = a * T(n/b) + O(n^d)</p>
<ul>
<li>$d &lt; log_b^a, O(n^{log_b^a})$</li>
<li>$d = log_b^a, O(n^d * logn)$</li>
<li>$d &gt; log_b^a, O(n^d)$<br>(log 不标底默认为2)</li>
</ul>
<p>归并排序<br>T(n) = 2T(n/2) + O(n) —&gt; T(n) = O(nlogn)</p>
<p>二分查找<br>T(n) = T(n/2) + O(1) —&gt; T(n) = O(logn)</p>
]]></content>
      <categories>
        <category>算法练习</category>
        <category>复杂度分析</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>复杂度分析</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵的搜索专题</title>
    <url>/2020/09/13/matrix-dfs/</url>
    <content><![CDATA[<h1 id="矩阵的搜索专题"><a href="#矩阵的搜索专题" class="headerlink" title="矩阵的搜索专题"></a>矩阵的搜索专题</h1><p>在二维或多维矩阵上做广度或者深度优先搜索算是比较经典的题了，但是因为不熟练，往往写的时间会耽搁，这里总结一下几道常见的矩阵dfs bfs搜索的题目，做个总结。</p>
<a id="more"></a>
<h2 id="二维矩阵的最短路径"><a href="#二维矩阵的最短路径" class="headerlink" title="二维矩阵的最短路径"></a><a href>二维矩阵的最短路径</a></h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">题目：给出n*n矩阵，第二行指定起始,终止坐标，求最短路径，只用# @是障碍物</span><br><span class="line">7</span><br><span class="line">0 0 0 3</span><br><span class="line">*5#++B+</span><br><span class="line">55.++++</span><br><span class="line">###$+++</span><br><span class="line">++$@$++</span><br><span class="line">+++$$++</span><br><span class="line">A++++##</span><br><span class="line">+++++#+</span><br></pre></td></tr></table></figure>
<p>这是一次笔试中遇到的题目，第一反应不知道怎么想的，居然用dfs。教训！</p>
<ul>
<li><strong>最短路径请用bfs</strong>，用dfs相当于递归遍历能到达终点的所有路径，选最短，运气好能提前搜到退出，但是太慢了。</li>
<li>矩阵的递归与二叉树的递归不同，二叉树没有回头路，矩阵要将走过的路设为visited，避免走回头路，递归退出的时候，要将visited设回0，当然也可以修改遍历的matrix，使得无法走回头路</li>
<li>时间复杂度 $O(N M 3^L)$ 这是一个很宽裕的上限，最坏情况每个都进入搜索，路径长度L，因为不走回头路，所以每个节点有3个方向选择（第一个节点4个）。但是如果求最短路径，bfs会更快搜到目标并退出，用bfs。</li>
<li>使用dfs注意矩阵的vis与复原，使用bfs注意保证不走回头路也要使用vis数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line">si, sj, ei, ej = list(map(int, input().split()))</span><br><span class="line">grid = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    grid.append(input())</span><br><span class="line"></span><br><span class="line">oriens = [(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">0</span>,<span class="number">-1</span>)]</span><br><span class="line">vis = [[<span class="number">0</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i, j</span>):</span></span><br><span class="line">    <span class="keyword">if</span> i == ei <span class="keyword">and</span> j == ej:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    res = float(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> orien <span class="keyword">in</span> oriens:</span><br><span class="line">        nxt_i, nxt_j = i+orien[<span class="number">0</span>], j+orien[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> nxt_i &lt; <span class="number">0</span> <span class="keyword">or</span> nxt_i &gt;= n <span class="keyword">or</span> nxt_j &lt; <span class="number">0</span> <span class="keyword">or</span> nxt_j &gt;= n:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> grid[nxt_i][nxt_j] == <span class="string">&#x27;#&#x27;</span> <span class="keyword">or</span> grid[nxt_i][nxt_j] == <span class="string">&#x27;@&#x27;</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> vis[nxt_i][nxt_j]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        vis[nxt_i][nxt_j] = <span class="number">1</span></span><br><span class="line">        ans = dfs(nxt_i, nxt_j) + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 记得要用vis，退出时设为0</span></span><br><span class="line">        vis[nxt_i][nxt_j] = <span class="number">0</span></span><br><span class="line">        res = min(res, ans)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">vis = [[<span class="number">0</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span>():</span></span><br><span class="line">    queue = deque([[si,sj,<span class="number">0</span>]])</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        i, j, step = queue.pop()</span><br><span class="line">        <span class="keyword">for</span> orien <span class="keyword">in</span> oriens:</span><br><span class="line">            nxt_i, nxt_j = i + orien[<span class="number">0</span>], j + orien[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> nxt_i &lt; <span class="number">0</span> <span class="keyword">or</span> nxt_i &gt;= n <span class="keyword">or</span> nxt_j &lt; <span class="number">0</span> <span class="keyword">or</span> nxt_j &gt;= n:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> grid[nxt_i][nxt_j] == <span class="string">&#x27;#&#x27;</span> <span class="keyword">or</span> grid[nxt_i][nxt_j] == <span class="string">&#x27;@&#x27;</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> vis[nxt_i][nxt_j]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nxt_i == ei <span class="keyword">and</span> nxt_j == ej:</span><br><span class="line">                <span class="keyword">return</span> step+<span class="number">1</span></span><br><span class="line">            vis[nxt_i][nxt_j] = <span class="number">1</span></span><br><span class="line">            queue.appendleft((nxt_i, nxt_j, step+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">vis[si][sj] = <span class="number">1</span></span><br><span class="line">ans = dfs(si, sj)</span><br><span class="line">print(ans)</span><br><span class="line"></span><br><span class="line">ans = bfs()</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure>
<h2 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索</a></h2><blockquote>
<p>board =<br>[[‘A’,’B’,’C’,’E’],<br>[‘S’,’F’,’C’,’S’],<br>[‘A’,’D’,’E’,’E’]]<br>给定 word = “ABCCED”, 返回 true<br>给定 word = “SEE”, 返回 true<br>给定 word = “ABCB”, 返回 false</p>
</blockquote>
<p>时间复杂度 $O(N M 3^L)$, 首先遍历二维矩阵，遇到字母与首字母相同，就dfs开始搜索，注意凡是进入dfs前，将vis置1，退出置0，首次进入dfs也不例外。为什么这题可以dfs呢？因为不是最短路径，单词的路线是线性的，不需要递归多个路径选最短，在这种情况下，其实dfs是更快的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span>(<span class="params">self, board: List[List[str]], word: str</span>) -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i, j, k</span>):</span></span><br><span class="line">            <span class="keyword">if</span> k == len(word):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            char = board[i][j]</span><br><span class="line">            board[i][j] = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> orien <span class="keyword">in</span> oriens:</span><br><span class="line">                nxt_i = orien[<span class="number">0</span>] + i</span><br><span class="line">                nxt_j = orien[<span class="number">1</span>] + j</span><br><span class="line">                <span class="keyword">if</span> nxt_i &lt; <span class="number">0</span> <span class="keyword">or</span> nxt_i &gt;= n:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> nxt_j &lt; <span class="number">0</span> <span class="keyword">or</span> nxt_j &gt;= m:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> board[nxt_i][nxt_j] == word[k]:</span><br><span class="line">                    <span class="keyword">if</span> dfs(nxt_i, nxt_j, k+<span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            board[i][j] = char</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        oriens = [(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">-1</span>),(<span class="number">0</span>,<span class="number">1</span>)]</span><br><span class="line">        n = len(board)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        m = len(board[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == word[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">if</span> dfs(i, j, <span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; oriens &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = board.size();</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == word[<span class="number">0</span>]) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span> (helper(board, word, <span class="number">1</span>, i, j)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    board[i][j] = word[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="built_in">string</span> &amp;word, <span class="keyword">int</span> index, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == word.size()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;orien : oriens) &#123;</span><br><span class="line">            <span class="keyword">int</span> nxt_i = i + orien[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> nxt_j = j + orien[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nxt_i &lt; <span class="number">0</span> || nxt_i &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (nxt_j &lt; <span class="number">0</span> || nxt_j &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (word[index] != board[nxt_i][nxt_j]) <span class="keyword">continue</span>;</span><br><span class="line">            board[nxt_i][nxt_j] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (helper(board, word, index+<span class="number">1</span>, nxt_i, nxt_j)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            board[nxt_i][nxt_j] = word[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></h2><blockquote>
<p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。假设该网格的四条边均被水包围。<br>输入:<br>[<br>[‘1’,’1’,’1’,’1’,’0’],<br>[‘1’,’1’,’0’,’1’,’0’],<br>[‘1’,’1’,’0’,’0’,’0’],<br>[‘0’,’0’,’0’,’0’,’0’]<br>]<br>输出: 1</p>
</blockquote>
<p>这一题也是典型的dfs搜素题，但是注意这与上面递归搜索不同，时间复杂度上限 O(nm)，因为对应遍历过的元素，不会再次进入，vis设为1之后不用置0，这是与上面最明显的区别。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span>(<span class="params">self, grid: List[List[str]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">i, j</span>):</span></span><br><span class="line">            queue = deque([(i,j)])</span><br><span class="line">            grid[i][j] = <span class="string">&quot;0&quot;</span></span><br><span class="line">            oriens = [(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">0</span>,<span class="number">-1</span>)]</span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                    row, col = queue.pop()</span><br><span class="line">                    <span class="keyword">for</span> orien <span class="keyword">in</span> oriens:</span><br><span class="line">                        nxt_row, nxt_col = row+orien[<span class="number">0</span>], col+orien[<span class="number">1</span>]</span><br><span class="line">                        <span class="keyword">if</span> nxt_row &lt; <span class="number">0</span> <span class="keyword">or</span> nxt_row &gt;= n <span class="keyword">or</span> nxt_col &lt; <span class="number">0</span> <span class="keyword">or</span> nxt_col &gt;= m:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                        <span class="keyword">if</span> grid[nxt_row][nxt_col] == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                        queue.appendleft((nxt_row, nxt_col))</span><br><span class="line">                        grid[nxt_row][nxt_col] = <span class="string">&quot;0&quot;</span></span><br><span class="line"></span><br><span class="line">        n = len(grid)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m = len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    bfs(i, j)</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; oriens &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> cnt;</span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;orien : oriens) &#123;</span><br><span class="line">            <span class="keyword">int</span> nxt_i = i + orien[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> nxt_j = j + orien[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nxt_i &lt; <span class="number">0</span> || nxt_i &gt;= grid.size() || nxt_j &lt; <span class="number">0</span> || nxt_j &gt;= grid[<span class="number">0</span>].size()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (grid[nxt_i][nxt_j] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            grid[nxt_i][nxt_j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            dfs(grid, nxt_i, nxt_j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="1254-统计封闭岛屿的数目"><a href="#1254-统计封闭岛屿的数目" class="headerlink" title="1254. 统计封闭岛屿的数目"></a><a href="https://leetcode-cn.com/problems/number-of-closed-islands/">1254. 统计封闭岛屿的数目</a></h2><blockquote>
<p>有一个二维矩阵 grid，陆地记号为0,水域记号为1。<br>如果一座岛屿 完全 由水域包围，即陆地边缘上下左右所有相邻区域都是水域，那么我们将其称为 「封闭岛屿」。如果该陆地处于边界，不算封闭岛屿。</p>
</blockquote>
<p>这一题和上一题基本一样，但是边界处陆地不属于封闭岛屿，所以需要前处理（c++版本），或者在递归里判断是否走到了边界（python版本）。更推荐前处理，将边界陆地先走一遍置为水域1，思路更模块化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closedIsland</span>(<span class="params">self, grid: List[List[int]]</span>) -&gt; int:</span></span><br><span class="line">        n = len(grid)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m = len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        oriens = [(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">-1</span>),(<span class="number">0</span>,<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i, j</span>):</span></span><br><span class="line">            <span class="keyword">for</span> orien <span class="keyword">in</span> oriens:</span><br><span class="line">                nxt_i, nxt_j = i+orien[<span class="number">0</span>], j+orien[<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> nxt_i &lt; <span class="number">0</span> <span class="keyword">or</span> nxt_i &gt;= n <span class="keyword">or</span> nxt_j &lt; <span class="number">0</span> <span class="keyword">or</span> nxt_j &gt;= m:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> nxt_i == <span class="number">0</span> <span class="keyword">or</span> nxt_i == n<span class="number">-1</span> <span class="keyword">or</span> nxt_j == <span class="number">0</span> <span class="keyword">or</span> nxt_j == m<span class="number">-1</span>:</span><br><span class="line">                    <span class="keyword">if</span> grid[nxt_i][nxt_j] == <span class="number">0</span>:</span><br><span class="line">                        self.flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> grid[nxt_i][nxt_j] == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                grid[nxt_i][nxt_j] = <span class="number">1</span></span><br><span class="line">                dfs(nxt_i, nxt_j)</span><br><span class="line"></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> i == n<span class="number">-1</span> <span class="keyword">or</span> j == <span class="number">0</span> <span class="keyword">or</span> j == m<span class="number">-1</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    self.flag = <span class="literal">True</span></span><br><span class="line">                    grid[i][j] = <span class="number">1</span></span><br><span class="line">                    dfs(i, j)</span><br><span class="line">                    <span class="keyword">if</span> self.flag:</span><br><span class="line">                        cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; oriens &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closedIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.empty()) <span class="keyword">return</span> cnt;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size();</span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">// 把边缘的陆地变为水域</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((i == <span class="number">0</span> || i == n<span class="number">-1</span> || j == <span class="number">0</span> || j == m<span class="number">-1</span>) &amp;&amp; grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    grid[i][j] = <span class="number">1</span>;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    grid[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;orien : oriens) &#123;</span><br><span class="line">            <span class="keyword">int</span> nxt_i = i + orien.first;</span><br><span class="line">            <span class="keyword">int</span> nxt_j = j + orien.second;</span><br><span class="line">            <span class="keyword">if</span> (nxt_i &lt; <span class="number">0</span> || nxt_i &gt;= grid.size() || nxt_j &lt; <span class="number">0</span> || nxt_j &gt;= grid[<span class="number">0</span>].size()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (grid[nxt_i][nxt_j] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            grid[nxt_i][nxt_j] = <span class="number">1</span>;</span><br><span class="line">            dfs(grid, nxt_i, nxt_j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a><a href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域</a></h2><blockquote>
<p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。<br>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。<br>X X X X<br>X O O X<br>X X O X<br>X O X X<br>变为<br>X X X X<br>X X X X<br>X X X X<br>X O X X</p>
</blockquote>
<p>其实这个和<a href="https://leetcode-cn.com/problems/number-of-closed-islands/">1254. 统计封闭岛屿的数目</a>完全一样，预处理把边界的O变成B（或者记录坐标即可），dfs二维矩阵X-&gt;O，再把O复原成O。 或者在搜索中记录路径index，检测是否遇到边界，没有的话该搜索退出后，把路径上的O变为X。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">self, board: List[List[str]]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        height = len(board)</span><br><span class="line">        <span class="keyword">if</span> height==<span class="number">0</span>: <span class="keyword">return</span> board</span><br><span class="line">        width = len(board[<span class="number">0</span>])</span><br><span class="line">        directions = [(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">0</span>,<span class="number">-1</span>)]</span><br><span class="line">        visited = set()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i,j</span>):</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> i == height<span class="number">-1</span> <span class="keyword">or</span> j == <span class="number">0</span> <span class="keyword">or</span> j == width<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span>, <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> (i,j) <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span>, <span class="literal">None</span></span><br><span class="line">            queue = [(i,j)]</span><br><span class="line">            visited.add((i,j))</span><br><span class="line">            result = [(i,j)]</span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                top = queue.pop()</span><br><span class="line">                <span class="keyword">for</span> direction <span class="keyword">in</span> directions:</span><br><span class="line">                    row = top[<span class="number">0</span>] + direction[<span class="number">0</span>]</span><br><span class="line">                    col = top[<span class="number">1</span>] + direction[<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> row&lt;<span class="number">0</span> <span class="keyword">or</span> row&gt;=height <span class="keyword">or</span> col&lt;<span class="number">0</span> <span class="keyword">or</span> col&gt;=width:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> (row,col) <span class="keyword">not</span> <span class="keyword">in</span> visited <span class="keyword">and</span> board[row][col] == <span class="string">&quot;O&quot;</span>:</span><br><span class="line">                        <span class="keyword">if</span> row == <span class="number">0</span> <span class="keyword">or</span> row == height<span class="number">-1</span> <span class="keyword">or</span> col == <span class="number">0</span> <span class="keyword">or</span> col == width<span class="number">-1</span>:</span><br><span class="line">                            flag = <span class="literal">False</span></span><br><span class="line">                        queue.append((row,col))</span><br><span class="line">                        visited.add((row,col))</span><br><span class="line">                        result.append((row,col))</span><br><span class="line">            <span class="keyword">return</span> flag, result</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(height):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(width):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&quot;O&quot;</span>:</span><br><span class="line">                    flag, result = dfs(i,j)</span><br><span class="line">                    <span class="keyword">if</span> flag:</span><br><span class="line">                        <span class="keyword">for</span> item <span class="keyword">in</span> result:</span><br><span class="line">                            row, col = item</span><br><span class="line">                            board[row][col] = <span class="string">&quot;X&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="864-获取所有钥匙的最短路径"><a href="#864-获取所有钥匙的最短路径" class="headerlink" title="864. 获取所有钥匙的最短路径"></a><a href="https://leetcode-cn.com/problems/shortest-path-to-get-all-keys/">864. 获取所有钥匙的最短路径</a></h2><blockquote>
<p>给定一个二维网格 grid。 “.” 代表一个空房间， “#” 代表一堵墙， “@” 是起点，（”a”, “b”, …）代表钥匙，（”A”, “B”, …）代表锁。<br>我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。<br>假设 K 为钥匙/锁的个数，且满足 1 &lt;= K &lt;= 6，字母表中的前 K 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。<br>返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 -1 。</p>
</blockquote>
<p>三维的bfs，求最短路径<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestPathAllKeys</span>(<span class="params">self, grid: List[str]</span>) -&gt; int:</span></span><br><span class="line">        mapping = &#123;<span class="string">&quot;a&quot;</span>:<span class="number">0</span>, <span class="string">&quot;b&quot;</span>:<span class="number">1</span>, <span class="string">&quot;c&quot;</span>:<span class="number">2</span>, <span class="string">&quot;d&quot;</span>:<span class="number">3</span>, <span class="string">&quot;e&quot;</span>:<span class="number">4</span>, <span class="string">&quot;f&quot;</span>:<span class="number">5</span>&#125;</span><br><span class="line">        n = len(grid)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        m = len(grid[<span class="number">0</span>])</span><br><span class="line">        nk = <span class="number">0</span></span><br><span class="line">        start = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                cell = grid[i][j]</span><br><span class="line">                <span class="keyword">if</span> cell.islower():</span><br><span class="line">                    nk |= (<span class="number">1</span>&lt;&lt;mapping[cell])</span><br><span class="line">                <span class="keyword">if</span> cell == <span class="string">&quot;@&quot;</span>:</span><br><span class="line">                    start = [i, j]</span><br><span class="line">        visited = [[[<span class="number">0</span> <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>&lt;&lt;len(mapping))] <span class="keyword">for</span> i <span class="keyword">in</span> range(m)] <span class="keyword">for</span> j <span class="keyword">in</span> range(n)]</span><br><span class="line">        row, col, k = start[<span class="number">0</span>], start[<span class="number">1</span>], <span class="number">0</span></span><br><span class="line">        queue = collections.deque([(row, col, k)])</span><br><span class="line">        orients = [[<span class="number">-1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">-1</span>],[<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">        level = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                row, col, k = queue.pop()</span><br><span class="line">                <span class="comment"># print(grid[row][col])</span></span><br><span class="line">                <span class="keyword">for</span> orient <span class="keyword">in</span> orients:</span><br><span class="line">                    nxt_row, nxt_col = row + orient[<span class="number">0</span>], col + orient[<span class="number">1</span>]</span><br><span class="line">                    nxt_k = k</span><br><span class="line">                    <span class="comment"># 越界</span></span><br><span class="line">                    <span class="keyword">if</span> nxt_row&lt;<span class="number">0</span> <span class="keyword">or</span> nxt_row&gt;=n <span class="keyword">or</span> nxt_col&lt;<span class="number">0</span> <span class="keyword">or</span> nxt_col&gt;=m:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    cell = grid[nxt_row][nxt_col]</span><br><span class="line">                    <span class="comment"># 该状态访问过</span></span><br><span class="line">                    <span class="keyword">if</span> visited[nxt_row][nxt_col][nxt_k]:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment"># 遇到墙</span></span><br><span class="line">                    <span class="keyword">if</span> cell == <span class="string">&quot;#&quot;</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment"># 遇到门,没相应的钥匙</span></span><br><span class="line">                    <span class="keyword">if</span> cell.isupper() <span class="keyword">and</span> (<span class="number">1</span>&lt;&lt;mapping[cell.lower()]) &amp; nxt_k == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment"># 遇到钥匙</span></span><br><span class="line">                    <span class="keyword">if</span> cell.islower():</span><br><span class="line">                        nxt_k |= (<span class="number">1</span>&lt;&lt;mapping[cell]) <span class="comment"># 重复没关系</span></span><br><span class="line">                        <span class="keyword">if</span> nxt_k == nk:</span><br><span class="line">                            <span class="keyword">return</span> level</span><br><span class="line"></span><br><span class="line">                    visited[nxt_row][nxt_col][nxt_k] = <span class="number">1</span></span><br><span class="line">                    queue.appendleft((nxt_row, nxt_col, nxt_k))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法练习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 39 40 216 377 组合-递归</title>
    <url>/2020/09/10/leetcode-combination-39-40-216-377/</url>
    <content><![CDATA[<h3 id="leetcode-四个组合系列题目"><a href="#leetcode-四个组合系列题目" class="headerlink" title="leetcode 四个组合系列题目"></a>leetcode 四个组合系列题目</h3><p>今天来做几个leetcode递归题，重点体会一下递归中的边界条件与递归控制，最后一题是动态规划，使用了从上到下的记忆化递归，可以体会下与递归的区别。题目本身不难，但是要一次ac还是对边界条件有考验，注意复杂度分析。附上题目与 python, c++ 代码。<br><a id="more"></a></p>
<h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></h4><blockquote>
<p>给定一个无重复元素的数组 candidates 和一个目标数 target<br>找出 candidates 中所有可以使数字和为 target 的组合。<br>candidates 中的数字可以无限制重复被选取。<br>1.所有数字（包括 target）都是正整数。<br>2.解集不能包含重复的组合。<br>输入：candidates = [2,3,6,7], target = 7,<br>所求解集为：<br>[[7],[2,2,3]]<br>输入：candidates = [2,3,5], target = 8,<br>所求解集为：<br>[[2,2,2,2],[2,3,3],[3,5]]</p>
</blockquote>
<p>条件：所给数组无重复元素，元素可重复被选取。 要求：不含重复组合的解集。</p>
<ul>
<li>第一想法就是在递归中使用 [0,n) 的for循环，保证元素可重复被选取，然而会产生重复解。比如 candidates = [1,2,3], target = 3, 会产生[1,2] [2,1]的重复解。</li>
<li>第二想法就是用哈希去重，但是涉及到频繁的哈希与数组的转换，不是个好方法</li>
<li>最终方案就是 [index,n) 的for循环，进入下一个递归时输入当前i作为下一个递归的起始index。这样可以保证 1.每个元素可以被重复选取 2.之后index开始的元素不会涵盖之前index开始的解。</li>
<li>ps：还sort(), break 了一下，剪枝下递归。</li>
</ul>
<p>时间复杂度 $O(n 2^n)$，每个数有可能选或不选，n个数递归次数最多就是O(2^n)，把res添加到result中O(n)，最极端的情况就是 $O(n 2^n)$<br>空间复杂度 O(max(n,target)) = 递归空间占用O(max(n,target)) + 递归中额外空间O(1) + 全局空间O(max(n,target))  (ps: res 可理解为全局数组，见C++解法)<br>递归复杂度的详细分析可参见我另一篇blog <strong><a href="https://xinjieinformatik.github.io/2020/09/11/recursion-complexity-analysis/">递归复杂度分析</a></strong><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span>(<span class="params">self, candidates: List[int], target: int</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        n = len(candidates)</span><br><span class="line">        candidates.sort()</span><br><span class="line">        result = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">index, res, target</span>):</span></span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">                result.append(res)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index, n):</span><br><span class="line">                <span class="keyword">if</span> target - candidates[i] &lt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                helper(i, res+[candidates[i]], target-candidates[i])</span><br><span class="line"></span><br><span class="line">        helper(<span class="number">0</span>, [], target)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line">        helper(candidates, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> index, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            result.push_back(res);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target - nums[i] &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            res.push_back(nums[i]);</span><br><span class="line">            helper(nums, i, target-nums[i]);</span><br><span class="line">            res.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></h4><blockquote>
<p>给定一个数组 candidates 和一个目标数 target ，<br>找出 candidates 中所有可以使数字和为 target 的组合。<br>candidates 中的每个数字在每个组合中只能使用一次。<br>1.所有数字（包括目标数）都是正整数。<br>2.解集不能包含重复的组合。<br>输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>所求解集为:<br>[[1, 7],[1, 2, 5],[2, 6],[1, 1, 6]]<br>输入: candidates = [2,5,2,1,2], target = 5,<br>所求解集为:<br>[[1,2,2],[5]]</p>
</blockquote>
<p>输入数组有重复元素，每个元素只能使用一次，输出数组不能包含重复组合 [1,7], [7,1]算重复组合。因此：</p>
<ul>
<li>先sort(), 然后通过candidates[i] != candidates[i-1]排除重复元素带来的影响</li>
<li>i == index or candidates[i] != candidates[i-1], helper(i+1) 保证每个元素只能使用一次(该层递归首个元素可以和前一个元素一样，其他不可以)</li>
<li>和为target后加入到输出数组，能保证无重复组合，可剪枝。</li>
</ul>
<p>时间复杂度 $O(n 2^n)$，每个数有可能选或不选，n个数递归次数最多就是O(2^n)，把res添加到result中O(n)，最极端的情况就是 $O(n 2^n)$<br>空间复杂度 O(max(n,target)) = 递归空间占用O(max(n,target)) + 递归中额外空间O(1) + 全局空间O(max(n,target))<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span>(<span class="params">self, candidates: List[int], target: int</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        candidates.sort()</span><br><span class="line">        n = len(candidates)</span><br><span class="line">        result = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">index, res, target</span>):</span></span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">                result.append(res)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index, n):</span><br><span class="line">                <span class="keyword">if</span> (i == index <span class="keyword">or</span> candidates[i] != candidates[i<span class="number">-1</span>]):</span><br><span class="line">                    temp = target - candidates[i]</span><br><span class="line">                    <span class="keyword">if</span> temp &lt; <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    helper(i+<span class="number">1</span>, res+[candidates[i]], temp)</span><br><span class="line">        helper(<span class="number">0</span>, [], target)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res = &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        helper(candidates, <span class="number">0</span>, target, &amp;result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> index, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; *result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            result-&gt;push_back(res);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == index || nums[i] != nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span> (target-nums[i] &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                res.push_back(nums[i]);</span><br><span class="line">                helper(nums, i+<span class="number">1</span>, target-nums[i], result);</span><br><span class="line">                res.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a href="https://leetcode-cn.com/problems/combination-sum-iii/">216. 组合总和 III</a></h4><blockquote>
<p>找出所有相加之和为 n 的 k 个数的组合。<br>组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。<br>1.所有数字都是正整数。<br>2.解集不能包含重复的组合。<br>输入: k = 3, n = 7<br>输出: [[1,2,4]]<br>输入: k = 3, n = 9<br>输出: [[1,2,6], [1,3,5], [2,3,4]]</p>
</blockquote>
<p>和上两题基本一样，多了个return的条件，k个数的组合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span>(<span class="params">self, k: int, n: int</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">res, index, target</span>):</span></span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span> <span class="keyword">and</span> len(res) == k:</span><br><span class="line">                result.append(res)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> len(res) == k:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(index, <span class="number">10</span>):</span><br><span class="line">                <span class="keyword">if</span> target-i &lt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                helper(res+[i], i+<span class="number">1</span>, target-i)</span><br><span class="line"></span><br><span class="line">        result = []</span><br><span class="line">        helper([], <span class="number">1</span>, n)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum3</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        len = k;</span><br><span class="line">        helper(<span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (res.size() == len <span class="keyword">and</span> target == <span class="number">0</span>) &#123;</span><br><span class="line">            result.push_back(res);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res.size() == len) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target - i &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            res.push_back(i);</span><br><span class="line">            helper(i+<span class="number">1</span>, target-i);</span><br><span class="line">            res.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a><a href="https://leetcode-cn.com/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h4><blockquote>
<p>给定一个由正整数组成且不存在重复数字的数组，<br>找出和为给定目标正整数的组合的个数。<br>nums = [1, 2, 3]<br>target = 4<br>所有可能的组合为：<br>(1, 1, 1, 1) (1, 1, 2) (1, 2, 1)<br>(1, 3) (2, 1, 1) (2, 2) (3, 1)<br>请注意，顺序不同的序列被视作不同的组合。<br>因此输出为 7。<br>进阶：<br>如果给定的数组中含有负数会怎么样？<br>问题会产生什么变化？<br>我们需要在题目中添加什么限制来允许负数的出现？</p>
</blockquote>
<p>注意题目 (1,1,2) (1,2,1) 属于不同组合，所以递归函数for范围是[0,n)<br>这题使用动态规划，因为观察可知存在大量重复计算<br>假设target为5，nums=[1,2]，递归树展开如下（同斐波那契）。fib(1),fib(2),fib(3)的组合数之前已经算过了，因此直接记忆化就好了。注意使用记忆化只能得到组合数，不能得到完整的路径，这也是一个能否使用记忆化的快速判别方法。<br><img data-src="/2020/09/10/leetcode-combination-39-40-216-377/fib_example.png" alt="fib_example"></p>
<p>如果数组含有负数，如nums=[-1,1,2,3]，则会有无穷个组合数，要加以限制，比如一个元素只能使用一次。</p>
<p>时间复杂度 $O(target * n)$，状态数 target，每次递归计算量 O(n)。<br>空间复杂度 O(max(n,target)) = 递归空间占用O(max(n,target)) + 递归中额外空间O(1) + 全局空间O(max(n,target))</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span>(<span class="params">self, nums: List[int], target: int</span>) -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line"><span class="meta">        @functools.lru_cache(None)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">res</span>):</span></span><br><span class="line">            <span class="keyword">if</span> res == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                val = res + nums[i]</span><br><span class="line">                <span class="keyword">if</span> val &gt; target:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                ans += helper(val)</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dp;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp.count(target) != <span class="number">0</span>) <span class="keyword">return</span> dp[target];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target - nums[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                res += helper(nums, target-nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[target] = res;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法练习</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
        <tag>dfs</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建个人博客 github + hexo + NexT</title>
    <url>/2020/09/09/build_your_blog_hexo/</url>
    <content><![CDATA[<h1 id="搭建个人博客-hexo"><a href="#搭建个人博客-hexo" class="headerlink" title="搭建个人博客 hexo"></a>搭建个人博客 hexo</h1><p>这篇文章介绍从0到1搭建个人博客, 基于 Github.io + hexo + NexT，完全免费也美观，对于个人博客来说完全够了，半天内可以搭建并自定义完成个人博客，推荐！<br><a id="more"></a></p>
<ul>
<li>基于github与hexo搭建博客，完全免费</li>
<li>hexo提供许多现成主题模板</li>
<li>经过配置后可使用latex。</li>
</ul>
<h2 id="建立-hexo-博客站点步骤"><a href="#建立-hexo-博客站点步骤" class="headerlink" title="建立 hexo 博客站点步骤"></a>建立 hexo 博客站点步骤</h2><ul>
<li>github 新建一个repository， 名称为 <code>你的GitHub用户名.github.io</code></li>
<li>确保NodeJS的安装目录与Git的安装目录在同一个文件夹下（<a href="https://stackoverflow.com/questions/45513441/npm-command-not-found-in-windows-10">参考</a>）</li>
<li>下载并安装NodeJS</li>
<li>下载并安装Git for Windows</li>
<li>打开Git bash 配置Git的用户名与邮箱为github用户名与邮箱，生成本地ssh并复制到github ssh上 （第一次使用Git设置，如果已经设置过，可以跳过该步骤）</li>
<li>选定一个文件夹作为存放博客文件的目录，以管理员身份打开Git bash， 并 cd 到该目录</li>
<li>导入nodejs路径到<code>git export PATH=$PATH:&quot;/D/path_to_nodejs&quot;</code> (windows path)</li>
<li>输入命令 <code>npm install hexo-cli -g</code></li>
<li>输入命令 <code>hexo init blog</code></li>
<li>输入命令 <code>cd blog</code></li>
<li>输入命令 <code>npm install</code></li>
<li>输入命令 <code>hexo s</code><br>s是server的缩写，表示启动本地服务器。默认情况下，访问网址是：<a href="http://localhost:4000/">http://localhost:4000/</a> 。如果成功的话可以看见官方的默认页面。</li>
<li>在blog文件夹下编辑_config.yml, 找到相应字段，修改如下<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://你的GitHub用户名.github.io/</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/你的GitHub用户名/你的GitHub用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></li>
<li>输入命令<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure></li>
<li>10几20分钟后打开浏览器，输入你的网站地址：<a href="https://你的GitHub用户名.github.io/，就可以看到你的网站已经上线了">https://你的GitHub用户名.github.io/，就可以看到你的网站已经上线了</a></li>
</ul>
<h2 id="新建并发布文章"><a href="#新建并发布文章" class="headerlink" title="新建并发布文章"></a>新建并发布文章</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo n <span class="string">&quot;newblog&quot;</span></span><br><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>
<p>在Git bash 命令行输入 hexo n “newblog”, 就可以看到在blog/source/_posts目录下多了一个newblog.md文件。写完之后生成、部署即可(运行 hexo g -d)。<br>要删除文章的话，直接把源文件删除即可（确保至少有一篇文章存在，否则可能出错）<br>同步到github.io通常要等待一段时间</p>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/78467553">一小时搭建完自己的个人网站</a></p>
<h2 id="常用的配置"><a href="#常用的配置" class="headerlink" title="常用的配置"></a>常用的配置</h2><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>Hexo有许多好看的主题，以NexT主题为例（使用的是NexT 7.8.0版本）：<br>下载主题：Releases · theme-next/hexo-theme-next<br>解压所下载的压缩包至站点的 themes 目录下，并将解压后的文件夹名称（hexo-theme-next-x.x.x）更改为 next<br>打开站点配置文件_config.yml，找到 theme 字段，并将其值更改为 next ；找到 language 字段，并将其值更改为 zh-CN（在themes/next/languages目录下可查看主题支持的语言）<br>在切换主题之后，使用 hexo clean 命令来清除 Hexo 的缓存</p>
<h3 id="LaTeX支持"><a href="#LaTeX支持" class="headerlink" title="LaTeX支持"></a>LaTeX支持</h3><p><a href="https://theme-next.js.org/docs/third-party-services/math-equations.html">配置latex</a></p>
<h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><p>安装一个能上传本地图片的插件：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><br>我一般会atom写markdown，多个blog的图片统一放在assets中</p>
<h3 id="文章添加tags-amp-category"><a href="#文章添加tags-amp-category" class="headerlink" title="文章添加tags&amp;category"></a>文章添加tags&amp;category</h3><p>设置blog\scaffolds\post, 每次 hexo n “new_blog” 默认会出现的标题<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 两数之和</span><br><span class="line">date: 2020-09-09 12:12:57</span><br><span class="line">categories:</span><br><span class="line">- 算法练习</span><br><span class="line">- leetcode</span><br><span class="line">tags:</span><br><span class="line">- 双指针</span><br><span class="line">- 哈希表</span><br><span class="line">---</span><br></pre></td></tr></table></figure><br>注意如上的categories是有层级关系的，leetcode从属于算法练习</p>
<h3 id="更换博客图片背景，设置透明度"><a href="#更换博客图片背景，设置透明度" class="headerlink" title="更换博客图片背景，设置透明度"></a>更换博客图片背景，设置透明度</h3><p>在 根目录/source下新建_data/styles.styl, 设置如下,<br>背景图片放在 根目录/source/images/<br>字体颜色等均可在这里改，覆盖全局参数<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">// Custom styles.</span><br><span class="line">// 整体背景设置</span><br><span class="line">body &#123;</span><br><span class="line">  background:url(/images/1_compress.jpg);// 设定背景图片,images同处于blog/<span class="built_in">source</span>文件夹下</span><br><span class="line"> 	background-repeat: no-repeat;// 设定背景图片非重复填充</span><br><span class="line">    background-attachment:fixed;// 设置背景图片不随页面滚动</span><br><span class="line">    background-position:50% 50%;// 设置背景图片位置</span><br><span class="line">  background-size: cover// 设置保持图像的纵横比并将图像缩放成将完全覆盖背景定位区域的最小大小</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 文章内容的透明度设置</span><br><span class="line">.content-wrap &#123;</span><br><span class="line">  opacity: 0.86;</span><br><span class="line">  color: <span class="comment">#000000;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// sidebar侧边工具栏样式属性</span><br><span class="line">.sidebar&#123;</span><br><span class="line">  opacity: 0.86</span><br><span class="line">  color: <span class="comment">#000000;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 页面头样式属性</span><br><span class="line">.header-inner &#123;</span><br><span class="line">  background: rgba(255,255,255,0.86);</span><br><span class="line">  color: <span class="comment">#000000;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 页脚颜色</span><br><span class="line">.footer &#123;</span><br><span class="line">  color: <span class="comment">#DCDCDC;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 搜索框（local-search）的透明度设置</span><br><span class="line">.popup &#123;</span><br><span class="line">  opacity: 0.86;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 向上箭头</span><br><span class="line">.back-to-top &#123;</span><br><span class="line">    opacity: 1;</span><br><span class="line">    line-height: 2.8;</span><br><span class="line">    right: 35px;</span><br><span class="line">    padding-right: 5px;</span><br><span class="line">    padding-left: 5px;</span><br><span class="line">    padding-top: 2.5px;</span><br><span class="line">    padding-bottom: 2.5px;</span><br><span class="line">    background-color: rgba(28, 28, 28, 1);</span><br><span class="line">    border-radius: 5px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="next主题美化与第三方插件"><a href="#next主题美化与第三方插件" class="headerlink" title="next主题美化与第三方插件"></a>next主题美化与第三方插件</h3><p>参考：</p>
<ul>
<li><a href="https://theme-next.js.org/docs/">NexT文档</a></li>
<li><a href="https://tding.top/archives/42c38b10.html">这个博客里有一系列教程,推荐!注意有些设置是低版本的</a></li>
<li><a href="http://eternalzttz.com/hexo-next.html">hexo NexT 主题美化，注意有些设置是低版本的</a></li>
<li><a href="https://tding.top/archives/58cff12b.html">Hexo-NexT 添加打字特效、鼠标点击特效</a></li>
<li><a href="https://jrbcode.gitee.io/posts/c13e56cd.html">时钟特效</a></li>
<li><a href="https://blog.csdn.net/weizhixiang/article/details/105112467">点击文章后从头开始阅读全文</a></li>
<li><a href="https://blog.csdn.net/chrishly3/article/details/103992492">next主题添加背景图片(无custom.styl情况)</a></li>
</ul>
<h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>一开始我启用了 <a href="https://www.tidio.com/panel/settings/live-chat/appearance">tidio</a> 在线聊天，busuanzi 站点访问统计<br>分析网页加载性能时，瓶颈主要在他们。介于对我来说，他们没那么重要，我就把他们都disable了，网页加载快了很多。</p>
<h3 id="关于TOC中文跳转失效的bug"><a href="#关于TOC中文跳转失效的bug" class="headerlink" title="关于TOC中文跳转失效的bug"></a>关于TOC中文跳转失效的bug</h3><p>NexT 7.3 以后版本自带toc了，在主题的config.yml中enable即可。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">toc:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure><br>但是遇到的问题是，当文章目录 toc 含有中文时，点击左侧目录栏无法正常跳转，查了很多资料，都没能解决（例如卸载hexo-toc（这东西就不用装）,标题文件命名规则等）。结果发现原来是js解析id的问题。。<br>打开node_modules\hexo\lib\plugins\helper\toc.js，修改如下<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// const href = id ? `#$&#123;encodeURL(id)&#125;` : null;</span></span><br><span class="line"><span class="keyword">const</span> href = id ? <span class="string">`#<span class="subst">$&#123;id&#125;</span>`</span> : <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><br>注意如果标题中含有空格，会被解析成-。但这些都不影响使用，把encodeURL去掉，就一切正常了。</p>
<h3 id="禁止部分markdown-gitalk-评论"><a href="#禁止部分markdown-gitalk-评论" class="headerlink" title="禁止部分markdown gitalk 评论"></a>禁止部分markdown gitalk 评论</h3><p>题头添加 comments: false<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: about</span><br><span class="line">date: 2020-09-09 13:26:08</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>hexo博客搭建</category>
      </categories>
      <tags>
        <tag>hexo博客搭建</tag>
      </tags>
  </entry>
</search>
